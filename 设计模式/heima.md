# 类图

## 类的表示方式

* 可见性表示：
  * +：public
  * -：private
  * #：protected
* 属性：可见性 名称 : 类型 [= 缺省值]
* 方法：可见性 名称(参数列表) [:  返回类型]

![1763028376733](image/heima/1763028376733.png)

## 类之间的关系表示

### 关联关系

#### 单向关联

* 单箭头的实线
* 一方存在另一方类型的成员变量

![1763028512230](image/heima/1763028512230.png)

#### 双向关联

* 不带箭头的实现
* 双方各自持有对方类型的成员变量

![1763028554829](image/heima/1763028554829.png)

#### 自关联

* 指向自身的箭头

![1763028634311](image/heima/1763028634311.png)

### 聚合关系

* 带空心菱形的实现表示，菱形指向整体
* 成员对象可以脱离整体对象独立存在

![1763028651954](image/heima/1763028651954.png)

### 组合关系

* 带实心菱形的实现表示，菱形指向整体
* 成员对象不可以脱离整体对象独立存在
* 整体对象可以控制部分对象的生命周期

![1763028777773](image/heima/1763028777773.png)

### 依赖关系

* 带箭头的虚线表示
* 耦合度最弱，是临时性的关联

![1763028819387](image/heima/1763028819387.png)

### 继承关系

* 带空心三角箭头的实线表示，箭头指向父类
* 父类和子类关系，继承

![1763028962283](image/heima/1763028962283.png)

### 实现关系

* 带空心三角箭头的虚线表示，箭头从实现类指向接口
* 接口和实现类的关系

![1763029021698](image/heima/1763029021698.png)

# 软件设计原则

## 开闭原则

* 对扩展开放，对修改关闭。不能修改原有代码
* 使用接口和抽象类（灵活性好）

## 里氏替换原则

* 任何基类可以出现的地方，子类一定可以出现
* 子类可以扩展父类功能，但是不能改变父类原有功能，尽量不要重写父类方法

![1763033229316](image/heima/1763033229316.png)

改进

![1763033238877](image/heima/1763033238877.png)

## 依赖倒转原则

* ⾼层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。
* 我们要⾯向接⼝编程，⽽不是⾯向实现编程。代码的依赖关系应该通过抽象
  （如接⼝或抽象类）来建⽴，⽽不是具体的实现类。
* 反例：
* ![1763033259750](image/heima/1763033259750.png)
* 改进
* ![1763033269395](image/heima/1763033269395.png)

## 接口隔离原则

* 客户端不应该被强迫依赖它不需要的接⼝。⼀个类对另⼀个类的依赖应该建⽴在最⼩的接⼝之上。

## 迪米特原则

* ⼀个软件实体应当尽可能少地与其他实体发⽣相互作⽤，只和最直接的部分交互

## 合成复用原则

* 尽量使⽤对象组合（合成/聚合）的⽅式，⽽不是继承来达到代码复⽤的⽬的。

# 创建者模式

将对象的创建和使用分离，降低系统的耦合度，使用者不需要关注对象的创建细节

## 单例模式

* 涉及到一个单一的类，负责创建自己的对象，提供一个访问其对象的唯一方式

### 角色

![1764855648656](image/heima/1764855648656.png)

* 单例类：只能创建一个实例
* 访问类：使用单例类

### 实现方式

* 饿汉式：类加载时单例就创建
* 懒汉式：类加载时单例不会被创建，首次使用才会创建
* 饿汉式

  * 方式1：静态成员变量
  * 方式2：静态代码块
  * 优点：类⼀加载就创建对象，天生线程安全，效率高。
  * 缺点：不是懒加载。如果这个实例从未使⽤过，会造成内存浪费。
* 懒汉式

  * 方式1：静态变量
  * 方式2：静态变量+加锁
  * 方式3：双重检查锁
  * 方式4：静态内部类
  * 方式5：枚举类

### 存在的问题

* 破坏了单例模式（序列化和反射）

### 应用场景

* 程序对于客户端只有一个可用的实例
* 需要严格地控制全局变量

## 工厂模式

### 简单工厂模式

* 优点
  * 可以通过参数直接获取对象
  * 避免修改客户端代码
  * 新产品只需要直接修改工厂类
* 缺点
  * 违背开闭原则

### 工厂方法

![1764856099882](image/heima/1764856099882.png)

* 角色组成

  * 抽象⼯⼚ (AbstractFactory)：声明了创建产品的抽象⽅法。
  * 具体⼯⼚ (ConcreteFactory)：实现抽象⽅法，负责创建具体的产品
  * 抽象产品 (AbstractProduct)：与简单⼯⼚模式相同
  * 具体产品 (ConcreteProduct)：与简单⼯⼚模式相同。
* 优缺点

  * 优点：完美遵循开闭原则，扩展性好。符合单⼀职责原则。
  * 缺点：每增加⼀个产品，就需要增加⼀个具体⼯⼚类

### 抽象工厂

![1764856964689](image/heima/1764856964689.png)

* 角色组成
  * 抽象⼯⼚ (AbstractFactory)：定义了创建⼀系列不同产品（⼀个产品族）的接⼝。
  * 具体⼯⼚ (ConcreteFactory)：实现接⼝，创建特定主题或⻛格的产品族。
  * 抽象产品 (AbstractProduct)：为产品族中的每⼀种产品定义接⼝。
  * 具体产品 (ConcreteProduct)：实现抽象产品接⼝，是具体⼯⼚创建的⽬标。

## 原型模式

* 用一个已经创建的实例作为原型，通过复制该原型对象创建一个相同的新对象

### 角色

* 抽象原型类：规定clone方法
* 具体原型类：实现clone方法
* 访问类：使用clone复制新对象

![1764836144952](image/heima/1764836144952.png)

### 浅克隆和深克隆

* 浅克隆：新对象属性和源对象属性相同，非基本类型属性，二者指向对象的内存地址相同
* 深克隆：新对象中属性中引用的其他对象也会被克隆，不再实现原有对象地址
* **Java中的 `clone`属于浅克隆**
* 使用深克隆需要使用对象流

### 使用场景

* 对象创建复杂
* 性能和安全要求比较高

## 建造者模式

* 将复杂对象的创建和表示分离，同样的创建过程可以创建不同的表示

### 角色

![1764838325121](image/heima/1764838325121.png)

* 生成器：规定产品的创建步骤
* 具体生成器：提供不同的创建实现，也可以创建不遵守通用步骤的产品
* 产品：要创建的对象
* 主管：调用构造步骤的顺序

（有时会将主管和生成器类合并）

### 优缺点

* 优点
  * 封装性好，产品和建造者类比较稳定
  * 解耦产品本身和产品创建
  * 可以精细地控制产品创建
  * 容易进行扩展
* 缺点
  * 建造者创建的产品一般有较多共同点，若产品差异较大，则不适合用

### 使用场景

* 创建对象较复杂，由多个部件构成，各部件变化大，但部件的构造顺序稳定
* 产品的构建和最终的表示是独立的

# 结构性模式
