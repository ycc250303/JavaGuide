# Spring & SpringBoot 常用注解

## SpringBoot 基础注解

* `@SpringBootApplication` 是 Spring Boot 应用的核心注解，通常用于标注主启动类。可以看成是下面三个注解的组合：

  * **`@EnableAutoConfiguration`** ：启用 Spring Boot 的自动配置机制。
  * **`@ComponentScan`** ：扫描 `@Component`、`@Service`、`@Repository`、`@Controller` 等注解的类。
  * **`@Configuration`** ：允许注册额外的 Spring Bean 或导入其他配置类。

## Spring Bean

### 依赖注入

* `@Autowired` 用于自动注入依赖项
  * 它可以标注在构造器、字段、Setter 方法或配置方法上，Spring 容器会自动查找匹配类型的 Bean 并将其注入
  * 当存在多个相同类型的 Bean 时，可能产生歧义。可以与 `@Qualifier` 结合使用，通过指定 Bean 的名称来精确选择需要注入的实例
* `@Primary` ：表示该 Bean 是**首选**的注入对象。当进行 `@Autowired` 注入时，如果没有使用 `@Qualifier` 指定名称，Spring 将优先选择带有 `@Primary` 的 Bean
* `@Resource(name="beanName")`：默认按**名称 (by Name)** 查找 Bean 进行注入，而 `@Autowired`默认按**类型 (by Type)**

### Bean 作用域

* `@Scope("scopeName")` 定义 Spring Bean 的作用域，即 Bean 实例的生命周期和可见范围。常用的作用域包括：
  * **singleton** : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。
  * **prototype** : 每次获取都会创建一个新的 bean 实例。也就是说，连续 `getBean()` 两次，得到的是不同的 Bean 实例。
  * **request** （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。
  * **session** （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。
  * **application/global-session** （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。
  * **websocket** （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。

### Bean注册

* 常见的一些注册 Bean 的注解：

  * `@Component`：通用的注解，可标注任意类为 `Spring` 组件。如果一个 Bean 不知道属于哪个层，可以使用 `@Component` 注解标注。
  * `@Repository` : 对应持久层即 Dao 层，主要用于数据库相关操作。
  * `@Service` : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
  * `@Controller` : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。
  * `@RestController`：一个组合注解，等效于 `@Controller` + `@ResponseBody`。它专门用于构建 RESTful Web 服务的控制器。标注了 `@RestController` 的类，其所有处理器方法（handler methods）的返回值都会被自动序列化（通常为 JSON）并写入 HTTP 响应体，而不是被解析为视图名称。
* `@Controller` vs `@RestController`：

  * `@Controller`：主要用于传统的 Spring MVC 应用，方法返回值通常是逻辑视图名，需要视图解析器配合渲染页面。如果需要返回数据（如 JSON），则需要在方法上额外添加 `@ResponseBody` 注解。
  * `@RestController`：专为构建返回数据的 RESTful API 设计。类上使用此注解后，所有方法的返回值都会默认被视为响应体内容（相当于每个方法都隐式添加了 `@ResponseBody`），通常用于返回 JSON 或 XML 数据。在现代前后端分离的应用中，`@RestController` 是更常用的选择。

## 配置

### 声明配置类

* `@Configuration` 主要用于声明一个类是 Spring 的配置类。

```java
@Configuration
public class AppConfig {

    // @Bean 注解用于在配置类中声明一个 Bean
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

    // 配置类中可以包含一个或多个 @Bean 方法。
}
```

### 读取配置信息

* `@Value("${property.key}")` 注入配置文件的单个属性值
* `@ConfigurationProperties`可以读取配置信息并与 Bean 绑定
  * ```java
    @ConfigurationProperties(prefix = "aliyun.oss")
    public class AliOssUtil {

        private String endpoint;
        private String accessKeyId;
        private String accessKeySecret;
        private String bucket;
    }
    ```

### 加载指定的配置文件

* `@PropertySource` 注解允许加载自定义的配置文件

```java
@Component
@PropertySource("classpath:website.properties")

class WebSite {
    @Value("${url}")
    private String url;
}
```

## MVC

### HTTP请求

* GET
  * `@GetMapping("users")`
* POST
  * `@PostMapping("users")`
  * `@PostMapping` 通常与 `@RequestBody` 配合，用于接收 JSON 数据并映射为 Java 对象
* PUT
  * `@PutMapping("/users/{userId}")`
* DELETE
  * `@DeleteMapping("/users/{userId}")`

### 参数绑定

#### 从URL路径中提取

```java
@GetMapping("/klasses/{klassId}/teachers")
public List<Teacher> getTeachersByClass(@PathVariable("klassId") Long klassId) {
    return teacherService.findTeachersByClass(klassId);
}
```

若请求 URL 为 `/klasses/123/teachers`，则 `klassId = 123`

#### 绑定查询参数

* `@RequestParam` 用于绑定查询参数
* 若请求 URL 为 `/klasses/123/teachers?type=web`，则 `klassId = 123`，`type = web`
* ```java
  @GetMapping("/klasses/{klassId}/teachers")
  public List<Teacher> getTeachersByClass(@PathVariable Long klassId,
                                          @RequestParam(value = "type", required = false) String type) {
      return teacherService.findTeachersByClassAndType(klassId, type);
  }
  ```

#### 绑定请求体中的json数据

* `@RequestBody` 用于读取 Request 请求的 body 部分并且**Content-Type 为 application/json** 格式的数据

## 数据校验

### 常用字段验证注解

* `@NotNull`: 检查被注解的元素（任意类型）不能为 `null`。
* `@NotEmpty`: 检查被注解的元素（如 `CharSequence`、`Collection`、`Map`、`Array`）不能为 `null` 且其大小/长度不能为 0。注意：对于字符串，`@NotEmpty` 允许包含空白字符的字符串，如 `" "`
* `@NotBlank`:不能为空白字符串。
* `@Null`: 检查被注解的元素必须为 `null`。
* `@AssertTrue` / `@AssertFalse`: 检查被注解的 `boolean` 或 `Boolean` 类型元素必须为 `true` / `false`。
* `@Min(value)` / `@Max(value)`: 检查被注解的数字类型（或其字符串表示）的值必须大于等于 / 小于等于指定的 `value`。适用于整数类型（`byte`、`short`、`int`、`long`、`BigInteger` 等）。
* `@DecimalMin(value)` / `@DecimalMax(value)`: 功能类似 `@Min` / `@Max`，但适用于包含小数的数字类型。`value` 必须是数字的字符串表示。
* `@Size(min=, max=)`: 检查被注解的元素大小/长度必须在指定的 `min` 和 `max` 范围之内（包含边界）。
* `@Digits(integer=, fraction=)`: 检查被注解的数字类型（或其字符串表示）的值，其整数部分的位数必须 ≤ `integer`，小数部分的位数必须 ≤ `fraction`。
* `@Pattern(regexp=, flags=)`: 检查被注解的 `CharSequence`（如 `String`）是否匹配指定的正则表达式 (`regexp`)。`flags` 可以指定匹配模式（如不区分大小写）。
* `@Email`: 检查被注解的 `CharSequence`是否符合 Email 格式（内置了一个相对宽松的正则表达式）。
* `@Past` / `@Future`: 检查被注解的日期或时间类型（`java.util.Date`、`java.util.Calendar`）是否在当前时间之前 / 之后。
* `@PastOrPresent` / `@FutureOrPresent`: 类似 `@Past` / `@Future`，但允许等于当前时间。

### 验证请求体

* 使用 `@RequestBody` 注解来接收请求体并将其绑定到一个对象时，可以在该参数前添加 `@Valid` 注解来触发对该对象的校验。

### 验证请求参数

* **在 Controller 类上添加 `@Validated` 注解** 
* **将校验注解直接放在方法参数上** ：将 `@Min`, `@Max`, `@Size`, `@Pattern` 等校验注解直接应用于对应的 `@PathVariable` 或 `@RequestParam` 参数。

## 全局异常处理

* `@ControllerAdvice` :注解定义全局异常处理
* `@ExceptionHandler` :注解声明异常处理方法

## 事务

* 在要开启事务的方法上使用 `@Transactional`注解即可
* `@Transactional` 注解一般可以作用在 `类`或者 `方法`上。
  * **作用于类** ：当把 `@Transactional` 注解放在类上时，表示所有该类的 public 方法都配置相同的事务属性信息。
  * **作用于方法** ：当类配置了 `@Transactional`，方法也配置了 `@Transactional`，方法的事务会覆盖类的事务配置信息。

## JPA

* 创建表： `@Entity` 用于声明一个类为 JPA 实体类，与数据库中的表映射。`@Table` 指定实体对应的表名。
* 主键：`@Id`声明字段为主键。`@GeneratedValue` 指定主键的生成策略。

  * **`GenerationType.TABLE`** ：通过数据库表生成主键。
  * **`GenerationType.SEQUENCE`** ：通过数据库序列生成主键（适用于 Oracle 等数据库）。
  * **`GenerationType.IDENTITY`** ：主键自增长（适用于 MySQL 等数据库）。
  * **`GenerationType.AUTO`** ：由 JPA 自动选择合适的生成策略（默认策略）。
* 字段映射：`@Column` 用于指定实体字段与数据库列的映射关系。

  * **`name`** ：指定数据库列名。
  * **`nullable`** ：指定是否允许为 `null`。
  * **`length`** ：设置字段的长度（仅适用于 `String` 类型）。
  * **`columnDefinition`** ：指定字段的数据库类型和默认值。
* 忽略字段：`@Transient` 用于声明不需要持久化的字段。
* 大字段存储：`@Lob` 用于声明大字段（如 `CLOB` 或 `BLOB`）
* 枚举类型映射：`@Enumerated` 用于将枚举类型映射为数据库字段。

## JSON数据处理

### 过滤Json字段

* `@JsonIgnoreProperties` 作用在类上用于过滤掉特定字段不返回或者不解析
* `@JsonIgnore`作用于字段或 `getter/setter` 方法级别，用于指定在序列化或反序列化时忽略该特定属性

### 格式化Json数据

* `@JsonFormat` 用于指定属性在序列化和反序列化时的格式。常用于日期时间类型的格式化。
* ```java
  // 指定 Date 类型序列化为 ISO 8601 格式字符串，并设置时区为 GMT
  @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "GMT")
  private Date date;
  ```

### 扁平化Json对象

* `@JsonUnwrapped` 注解作用于字段上，用于在序列化时将其嵌套对象的属性“提升”到当前对象的层级，反序列化时执行相反操作。这可以使 JSON 结构更扁平。

## 测试
