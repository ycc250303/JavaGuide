# Java 集合 —— 面试提问与解答

> 本文面向面试场景，聚焦高频问法与要点回答，必要处给出简短示例或关键术语，便于快速复盘。

## 基础与总体

### 问：Java 集合框架总体如何划分？
答：`Collection`（`List`/`Set`/`Queue`）与 `Map` 两大体系。`List` 有序可重复，`Set` 不重复可能有序（`TreeSet` 有序，`HashSet` 无序），`Queue` 支持队列/双端队列/阻塞队列，`Map` 存键值对。

### 问：`ArrayList` 与 `LinkedList` 如何选择？
答：随机访问与内存局部性选 `ArrayList`；频繁头部插入/删除或双端操作且不关心随机访问选 `LinkedList`。并发下两者均非线程安全。

## List 相关

### 问：`ArrayList` 扩容机制是怎样的？为什么是 1.5 倍？
答：容量不足时创建更大新数组并复制旧数据，JDK 默认按 1.5 倍左右增长，平衡扩容次数与内存浪费；首次常见触发为第 11 个元素（默认容量与 ensure 逻辑）。

### 问：`List` 与数组如何互转？
答：`toArray()` 返回 `Object[]` 丢类型；`toArray(T[])` 可保持类型：`list.toArray(new Integer[list.size()])` 或 `list.toArray(Integer[]::new)`。

### 问：`CopyOnWriteArrayList` 读写特性与适用场景？
答：读无锁，写时复制（写-写互斥），读到旧值属弱一致性；适合读多写少；写开销 O(n) 且额外内存占用。

## Map 相关

### 问：`HashMap` 为什么容量是 2 的幂次方？
答：便于用 `hash & (n-1)` 代替 `%`，更高效；扩容后通过高位判断去留（位置不变或索引+旧容量），有利于均匀分布与高效迁移。

### 问：JDK1.8 `HashMap` 何时树化？为何先扩容后树化？
答：当链表长度≥8 且数组长度≥64 才树化；若数组较小先扩容，避免过早引入树结构的复杂性与额外开销。

### 问：`HashMap` 扩容（`resize`）的成本与优化思路？
答：需要重哈希并遍历所有元素，代价大；尽量在已知数据量时设置更精确初始容量，降低扩容次数。

### 问：`HashMap` 与 `Hashtable` 区别？
答：是否线程安全（后者全表同步，性能差）、是否支持 `null`（`HashMap` 支持单个 null key 与多个 null value）、扩容策略不同、哈希扰动不同。

### 问：`HashMap` 与 `TreeMap` 有何差异？
答：`TreeMap` Key 有序并提供 `NavigableMap` 的定向/边界/子集视图/逆序能力；`HashMap` 无序但平均 O(1) 操作。

### 问：`ConcurrentHashMap` 与 `Hashtable` 有何差异？
答：`ConcurrentHashMap`（1.8）基于 `Node + CAS + synchronized`，仅锁桶首节点，粒度更细；`Hashtable` 方法级 `synchronized` 单锁，竞争大、性能差。

### 问：`ConcurrentHashMap` 为什么 key 和 value 不能为 null？
答：避免二义性：无法区分“键不存在返回 null”与“键存在但值为 null”。可用哨兵对象替代。

### 问：`ConcurrentHashMap` 能否保证复合操作原子性？
答：提供 `putIfAbsent`、`compute*`、`merge` 等原子复合操作；组合多次 `get/put/remove` 不能天然保证原子性。

## Set 相关

### 问：`HashSet`、`LinkedHashSet`、`TreeSet` 如何选择？
答：是否有序与排序需求：无序用 `HashSet`；需按照插入顺序迭代用 `LinkedHashSet`；需排序（自然/定制）用 `TreeSet`。三者均需正确实现 `equals`/`hashCode`（或提供比较器）。

### 问：`HashSet` 如何判重？
答：先比 `hashCode` 再比 `equals`，两者都相同才视为重复不插入。

## Queue / Deque / 并发队列

### 问：`ArrayDeque` 与 `LinkedList` 实现队列/栈的优劣？
答：`ArrayDeque` 基于数组与循环缓冲，均摊 O(1) 插入删除，空间局部性好；`LinkedList` 节点分配开销更高，通常性能逊于 `ArrayDeque`。

### 问：`PriorityQueue` 的时间复杂度与特性？
答：基于二叉堆，插入与删除堆顶均 O(log n)；非线程安全；默认小顶堆，可传比较器自定义。

### 问：`ArrayBlockingQueue` 与 `LinkedBlockingQueue` 区别？
答：数组 vs 链表；必须有界 vs 可不指定上界；单把锁 vs 生产/消费锁分离；内存预分配 vs 按需分配。

### 问：`ArrayBlockingQueue` 与 `ConcurrentLinkedQueue` 区别？
答：有界阻塞队列（数组，支持阻塞/超时）vs 无界非阻塞队列（链表，CAS）。

### 问：`DelayQueue` 适用场景与实现要点？
答：延时任务（如订单超时取消），底层 `PriorityQueue` + `ReentrantLock` + `Condition`，按到期时间升序出队；`offer/take/poll/peek` 分别对应入队与不同获取方式。

## 代码与实现细节（精要）

### LRU 缓存用 `LinkedHashMap` 如何实现？
答：构造 `accessOrder=true`，重写 `removeEldestEntry`：当 `size()>capacity` 返回 true 即淘汰最老元素。

```java
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;
    public LRUCache(int capacity) {
        super(capacity, 0.75f, true);
        this.capacity = capacity;
    }
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > capacity;
    }
}
```

### `CopyOnWriteArrayList` 为什么 `get` 可能读到旧值？
答：`get` 无锁，先取当前 `array` 引用再读索引，期间若有写操作替换了 `array`，读线程仍从旧数组读值（弱一致）。

### `ConcurrentHashMap` 1.7 与 1.8 的并发控制差异？
答：1.7 使用 `Segment` 分段锁；1.8 取消 `Segment`，用 `CAS + synchronized`，仅锁桶首或树根，冲突更小时并发度更高。
