# 多线程基础

## 创建线程三种方式

### 继承Thread类

创建一个类继承 Thread 类，并重写 run 方法。

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName() + ":打了" + i + "个小兵");
        }
    }
}
```

### 实现 Runnable 接口

创建一个类实现 Runnable 接口，并重写 run 方法。

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            try {//sleep会发生异常要显示处理
                Thread.sleep(20);//暂停20毫秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "打了:" + i + "个小兵");
        }
    }
}
```

### 实现 Callable 接口

实现 Callable 接口，重写 call 方法，这种方式可以通过 FutureTask 获取任务执行的返回值。

```java
public class CallerTask implements Callable<String> {
    public String call() throws Exception {
        return "Hello,i am running!";
    }

    public static void main(String[] args) {
        //创建异步任务
        FutureTask<String> task=new FutureTask<String>(new CallerTask());
        //启动线程
        new Thread(task).start();
        try {
            //等待执行完成，并获取返回结果
            String result=task.get();
            System.out.println(result);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

## 关于线程

### 为什么要重写run方法

这是因为默认的 `run()`方法不会做任何事情。为了让线程执行一些实际的任务，我们需要提供自己的 `run()`方法实现，这就需要重写 `run()`方法。

### run方法和start方法区别？

* `run()`：封装线程执行的代码，直接调用相当于调用普通方法。
* `start()`：启动线程，然后由 JVM 调用此线程的 `run()` 方法。

### 通过继承 Thread 的方法和实现 Runnable 接口的方式创建多线程，哪个好？

实现 Runable 接口好，原因有两个：

* 避免了 Java 单继承的局限性，Java 不支持多重继承，因此如果我们的类已经继承了另一个类，就不能再继承 Thread 类了。
* 适合多个相同的程序代码去处理同一资源的情况，把线程、代码和数据有效的分离，更符合面向对象的设计思想。Callable 接口与 Runnable 非常相似，但可以返回一个结果。

## 控制线程其他方法

* `sleep()`：使当前正在执行的线程暂停指定的毫秒数，也就是进入休眠的状态。要对异常进行处理。
* `join()`：等待这个线程执行完才会轮到后续线程得到 cpu 的执行权，使用这个也要捕获异常。
* `setDaemon()`：将此线程标记为守护线程，准确来说，就是服务其他的线程，像 Java 中的垃圾回收线程，就是典型的守护线程。
* `yield()`：yield() 方法是一个静态方法，用于暗示当前线程愿意放弃其当前的时间片，允许其他线程执行。然而，它只是向线程调度器提出建议，调度器可能会忽略这个建议。

## 线程生命周期

![1762734021190](image/并发-二哥/1762734021190.png)

# 获取线程的执行结果

## 异步计算接口Future接口

```java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

* 提供的功能

  * 判断任务是否完成；
  * 能够中断任务；
  * 能够获取任务执行结果。
* `cancel()` 方法用来取消任务，如果取消任务成功则返回 true，如果取消任务失败则返回 false。

  * 参数 mayInterruptIfRunning 表示是否允许取消正在执行却没有执行完毕的任务，如果设置 true，则表示可以取消正在执行过程中的任务。
  * 如果任务已经完成，则无论 mayInterruptIfRunning 为 true 还是 false，此方法肯定返回 false，即如果取消已经完成的任务会返回 false；
  * 如果任务正在执行，若 mayInterruptIfRunning 设置为 true，则返回 true，若 mayInterruptIfRunning 设置为 false，则返回 false；
  * 如果任务还没有执行，则无论 mayInterruptIfRunning 为 true 还是 false，肯定返回 true。
* `isCancelled()` 方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。
* `isDone()` 方法表示任务是否已经完成，若任务完成，则返回 true；
* `get()`方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；
* `get(long timeout, TimeUnit unit)`用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回 null。

## 异步计算结果 FutureTask

# Java线程的6种状态

![1762959066356](image/并发-二哥/1762959066356.png)

```java
// Thread.State 源码
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
```

## NEW

* 线程此时尚未启动，还没调用 Thread 实例的 `start()`方法。
* 反复调用同一个线程的 start 方法是否可行？**不行**

## RUNNABLE

* 表示当前线程正在运行中。此时线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配资源。
* Java 线程的**RUNNABLE**状态包括了操作系统线程的**ready**和**running**两个状态。

## BLOCKED

* 阻塞状态。处于 BLOCKED 状态的线程正等待锁的释放以进入同步区

## WAITING

* 等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒。
* 这 3 个方法会使线程进入等待状态：
  * `Object.wait()`：使当前线程处于等待状态直到另一个线程唤醒它；
  * `Thread.join()`：等待线程执行完毕，底层调用的是 Object 的 wait 方法；
  * `LockSupport.park()`：除非获得调用许可，否则禁用当前线程进行线程调度。

## TIMED_WAITING

* 超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。
* 调用如下方法会使线程进入超时等待状态：

  * `Thread.sleep(long millis)`：使当前线程睡眠指定时间；
  * `Object.wait(long timeout)`：线程休眠指定时间，等待期间可以通过 `notify()`/`notifyAll()`唤醒；
  * `Thread.join(long millis)`：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行；
  * `LockSupport.parkNanos(long nanos)`： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；
  * `LockSupport.parkUntil(long deadline)`：同上，也是禁止线程进行调度指定时间；

## TERMINATED

* 终止状态。此时线程已执行完毕。

## 线程状态转换

![1762961121575](image/并发-二哥/1762961121575.png)

## 线程中断

Thread 类里提供的关于线程中断的几个方法：

* `Thread.interrupt()`：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为 true（默认是 false）；
* `Thread.isInterrupted()`：测试当前线程是否被中断。
* `Thread.interrupted()`：检测当前线程是否被中断，与 `isInterrupted()` 方法不同的是，这个方法如果发现当前线程被中断，会清除线程的中断状态。

# 线程安全

## 原子性

* 原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
* 并发编程中很多操作都不是原子操作，如果不加锁的话，可能会得到意料之外的值。

## 可见性

* 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
* 每个线程都有属于自己的工作内存，工作内存和主内存间需要通过 store 和 load 等进行交互。
* Java 提供了 `volatile`这个关键字。当一个共享变量被 volatile 修饰时，它会保证修改的值立即更新到主存当中，这样的话，当有其他线程需要读取时，就会从内存中读到新值

![1762966711648](image/并发-二哥/1762966711648.png)

## 活跃性问题

* 活跃性是指某件正确的事情最终会发生，但当某个操作无法继续下去的时候，就会发生活跃性问题。
  * 死锁：多个线程因为环形等待锁的关系而永远地阻塞下去。
  * 活锁：多个线程都在运行并且都在修改各自的状态，而其他线程又依赖这个状态，就导致任何一个线程都无法继续执行
  * 饥饿
    * 高优先级的线程一直在运行消耗 CPU，所有的低优先级线程一直处于等待；
    * 一些线程被永久堵塞在一个等待进入同步块的状态，而其他线程总是能在它之前持续地对该同步块进行访问；

## 性能问题

* 多线程有 `创建线程`和 `线程上下文切换`的开销。
* 一般减少上下文切换的方法有：
  * 无锁并发编程：可以参照 [ConcurrentHashMap](https://javabetter.cn/thread/ConcurrentHashMap.html) 锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间。
  * CAS 算法，利用 [Atomic](https://javabetter.cn/thread/atomic.html) + [CAS](https://javabetter.cn/thread/cas.html) 算法来更新数据，采用乐观锁的方式，可以有效减少一部分不必要的锁竞争带来的上下文切换。
  * 使用最少线程：避免创建不必要的线程，如果任务很少，但创建了很多的线程，这样就会造成大量的线程都处于等待状态。
  * 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

# Java内存模型 JMM
