# JVM

## JVM架构

* 类加载器
* 运行时数据区
* 执行引擎

![1763608834482](image/二哥/1763608834482.png)

![1763608849615](image/二哥/1763608849615.png)

### 类加载器

* 加载.class文件
* 将字节码加载到内存中
* 加载--连接--实例化

### 执行引擎

* 将字节码指令解释为平台本地机器指令
* 将高级语言翻译为机器语言
* 解释器：读取字节码，然后执行指令。因为它是一行一行地解释和执行指令，所以它可以很快地解释字节码，但是执行起来会比较慢 。
* 即时编译器：选择性的把一些热点代码编译成本地代码。执行本地代码比一条一条进行解释执行的速度快很多，因为本地代码是保存在缓存里的。
* 垃圾回收器，用来回收堆内存中的垃圾对象。

## Java内存区域

### 运行时数据区

* JDK1.7：
* ![1763784164461](image/二哥+JavaGuide/1763784164461.png)
* JDK1.8，将方法区和运行时常量池迁移到本地内存
* ![1763784172358](image/二哥+JavaGuide/1763784172358.png)
* 线程私有：程序计数器、虚拟机栈、本地方法栈
* 线程共享：堆、方法区、直接内存

### 程序计数器

* 实现代码流程控制（顺序、选择、循环、异常处理等）
* 多线程环境下，记录当前线程的执行位置

### Java虚拟机栈

* 除了Native方法，其他Java方法都是通过栈实现的
* 栈由一个个栈帧组成，每个栈帧包括：
  * 局部变量表
  * 操作数栈
  * 动态链接
  * 方法返回地址
* 局部变量表
  * 存放编译期间可知的各种数据类型（int、long等）、对象引用
* 操作数栈
  * 用于存放方法执行过程中产生的中间计算结果和计算过程中产生的临时变量
* 动态链接
  * 在 Class 文件中，方法调用以**符号引用**的形式存在于常量池。为了执行调用，需要被转换为内存中的**直接引用**
  * 对于需要根据对象实际类型才能确定具体实现的 **虚方法** （这是实现多态的基础），这个转换过程则被推迟到 **程序运行期间** ，由**动态链接**来完成

### 本地方法栈

* 为Native方法服务，存放本地方法的局部变量表、操作数栈、动态链接、出口信息。

### 堆

* **此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**
* 从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用，那么对象可以直接在栈上分配内存。
* 垃圾收集器管理的主要区域

### 方法区

* 主要存储以下数据：
  * 类的元数据
  * 方法的字节码
  * 运行时常量池
* 不存储在方法区内的：
  * 静态变量：堆
  * 字符串常量池：堆
  * 代码缓存：缓存

![1763813933492](image/二哥+JavaGuide/1763813933492.png)

* 方法区/永久代变为元空间：
  * 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存
  * 元空间里面存放的是类的元数据，能加载的类更多
  * 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低

### 运行时常量池

### 字符串常量池

* 避免字符串的重复创建

### 直接内存

## HotSpot虚拟机

### 创建对象

* 1.类加载检查
  * 虚拟机遇到一条 new 指令时
  * 首先将检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。
  * 如果没有，那必须先执行相应的类加载过程。
* 2.分配内存
  * 对象所需的内存大小在类加载完成后便可确定
  * 把一块确定大小的内存从 Java 堆中划分出来
* 3.初始化零值
  * 虚拟机将分配到的内存空间都初始化为零值
* 4.设置对象头
  * 对对象进行设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息
* 5.执行init方法
  * 此时从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零
  * 执行 `<init>` 方法，把对象按照程序员的意愿进行初始化


* 内存分配两种方式

  * 指针碰撞
    * 适用场合：堆内存规整（即没有内存碎片）的情况下。
    * 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
  * 空闲列表
    * 适用场合：堆内存不规整的情况下。
    * 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
* 内存分配并发问题

  * **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
  * **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

### 对象内存布局

* **对象头（Header）** 、 **实例数据（Instance Data）**和**对齐填充（Padding）** 。
* 对象头：
  * 标记字段：用于存储对象自身的运行时数据
  * 类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
* 实例数据：**对象真正存储的有效信息** ，也是在程序中所定义的各种类型的字段内容
* 对齐填充：占位，类似高程

### 对象访问定位

* 使用句柄
  * Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。
  * 优点：稳定，对象被移动后只需要改变示例数据指针
  * ![1763823624194](image/二哥+JavaGuide/1763823624194.png)
* 直接指针
  * 如果使用直接指针访问，reference 中存储的直接就是对象的地址。
  * 优点：速度快
  * ![1763823642326](image/二哥+JavaGuide/1763823642326.png)

## 类加载过程

![1763611465737](image/二哥/1763611465737.png)

### 加载

* 将字节码从不同的数据源（可能是 class 文件、也可能是 jar 包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的 `java.lang.Class` 对象

### 验证

* 对二进制字节流进行校验，符合JVM字节码规范才能被执行
* 检查内容：
  * 确保二进制字节流格式符合预期（比如说是否以 `cafe babe` 开头）
  * 是否所有方法都遵守[访问控制关键字](https://javabetter.cn/oo/access-control.html)的限定（protected、private 那些）
  * 方法调用的参数个数和类型是否正确。
  * 确保变量在使用之前被正确初始化了。
  * 检查变量是否被赋予恰当类型的值。

### 准备

* 对类变量（`static`）分配内存并初始化

```java
public String chenmo = "沉默";
public static String wanger = "王二";
public static final String cmower = "沉默王二";
```

* chenmo 不会被分配内存，而 wanger 会；但 wanger 的初始值不是“王二”而是 `null`
* `static final` 修饰的变量被称作为常量，和类变量不同。常量一旦赋值就不会改变了，所以 cmower 在准备阶段的值为“沉默王二”而不是 `null`。

### 解析

* 将常量池中的符号引用转化为直接引用
* 符号引用：以符号描述所引用的目标（可以无歧义定位到目标）
* 直接引用：通过对符号解析，找到引用的实际内存地址

### 初始化

* 在准备阶段，类变量已经被赋过默认初始值，而在初始化阶段，类变量将被赋值为代码期望赋的值。
* 对变量进行实例化
* 初始化时机：
  * 创建类的实例时。
  * 访问类的静态方法或静态字段时（除了 final 常量，它们在编译期就已经放入常量池）。
  * 使用 java.lang.reflect 包的方法对类进行反射调用时。
  * 初始化一个类的子类（首先会初始化父类）。
  * JVM 启动时，用户指定的主类（包含 main 方法的类）将被初始化。

### 卸载

* 卸载类需要满足的三个要求：
  * 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
  * 该类没有在其他任何地方被引用
  * 该类的类加载器的实例已被 GC

## 类加载器

* 赋予了Java类可以被动态加载到JVM中并执行的能力
* 类加载器是一个负责加载类的对象，用于实现类加载过程中的**加载**这一步。
* 每个 Java 类都有一个引用指向加载它的 `ClassLoader`。
* 数组类不是通过 `ClassLoader` 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。
* **类加载器的主要作用就是动态加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。**

### 加载规则

* 并不会一次性加载所有的类，而是根据需要去动态加载
* 已经加载的类会被放在 `ClassLoader` 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载

### JVM的类加载器

* **`BootstrapClassLoader`(启动类加载器)** ：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）
* **`ExtensionClassLoader`(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
* **`AppClassLoader`(应用程序类加载器)** ：面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。
* 除了 `BootstrapClassLoader` 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 `ClassLoader`抽象类。
* 这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类

## 双亲委派模型

* `ClassLoader` 类使用委托模型来搜索类和资源。
* 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
* `ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。

![1763615700937](https://file+.vscode-resource.vscode-cdn.net/d%3A/GitHub/ycc/JavaGuide/Java/JVM/image/%E4%BA%8C%E5%93%A5+JavaGuide/1763615700937.png)

### 双亲委派模型执行过程

* 在类加载的时候，首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。
* 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。
* 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。
* 如果子类加载器也无法加载这个类，那么它会抛出一个 `ClassNotFoundException` 异常。
* 判断两个类是否相同：

  * 类的全名是否相同
  * 类的加载器是否一样

### 双亲委派模型的好处

* 避免类的重复加载和防止核心 API 被篡改
