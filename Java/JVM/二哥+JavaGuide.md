# JVM

## JVM架构

* 类加载器
* 运行时数据区
* 执行引擎

![1763608834482](image/二哥/1763608834482.png)

![1763608849615](image/二哥/1763608849615.png)

### 类加载器

* 加载.class文件
* 将字节码加载到内存中
* 加载--连接--实例化

### 运行时数据区

* 存放字节码信息和程序执行过程中的数据
* 包括：方法区、堆、虚拟机栈、本地方法栈以及程序计数器

### 执行引擎

* 将字节码指令解释为平台本地机器指令
* 将高级语言翻译为机器语言
* 解释器：读取字节码，然后执行指令。因为它是一行一行地解释和执行指令，所以它可以很快地解释字节码，但是执行起来会比较慢 。
* 即时编译器：选择性的把一些热点代码编译成本地代码。执行本地代码比一条一条进行解释执行的速度快很多，因为本地代码是保存在缓存里的。
* 垃圾回收器，用来回收堆内存中的垃圾对象。

## 类加载过程

![1763611465737](image/二哥/1763611465737.png)

### 加载

* 将字节码从不同的数据源（可能是 class 文件、也可能是 jar 包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的 `java.lang.Class` 对象

### 验证

* 对二进制字节流进行校验，符合JVM字节码规范才能被执行
* 检查内容：
  * 确保二进制字节流格式符合预期（比如说是否以 `cafe babe` 开头）
  * 是否所有方法都遵守[访问控制关键字](https://javabetter.cn/oo/access-control.html)的限定（protected、private 那些）
  * 方法调用的参数个数和类型是否正确。
  * 确保变量在使用之前被正确初始化了。
  * 检查变量是否被赋予恰当类型的值。

### 准备

* 对类变量（`static`）分配内存并初始化

```java
public String chenmo = "沉默";
public static String wanger = "王二";
public static final String cmower = "沉默王二";
```

* chenmo 不会被分配内存，而 wanger 会；但 wanger 的初始值不是“王二”而是 `null`
* `static final` 修饰的变量被称作为常量，和类变量不同。常量一旦赋值就不会改变了，所以 cmower 在准备阶段的值为“沉默王二”而不是 `null`。

### 解析

* 将常量池中的符号引用转化为直接引用
* 符号引用：以符号描述所引用的目标（可以无歧义定位到目标）
* 直接引用：通过对符号解析，找到引用的实际内存地址

### 初始化

* 在准备阶段，类变量已经被赋过默认初始值，而在初始化阶段，类变量将被赋值为代码期望赋的值。
* 对变量进行实例化
* 初始化时机：
  * 创建类的实例时。
  * 访问类的静态方法或静态字段时（除了 final 常量，它们在编译期就已经放入常量池）。
  * 使用 java.lang.reflect 包的方法对类进行反射调用时。
  * 初始化一个类的子类（首先会初始化父类）。
  * JVM 启动时，用户指定的主类（包含 main 方法的类）将被初始化。

### 卸载

* 卸载类需要满足的三个要求：
  * 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
  * 该类没有在其他任何地方被引用
  * 该类的类加载器的实例已被 GC

## 类加载器

* 赋予了Java类可以被动态加载到JVM中并执行的能力
* 类加载器是一个负责加载类的对象，用于实现类加载过程中的**加载**这一步。
* 每个 Java 类都有一个引用指向加载它的 `ClassLoader`。
* 数组类不是通过 `ClassLoader` 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。
* **类加载器的主要作用就是动态加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。**

### 加载规则

* 并不会一次性加载所有的类，而是根据需要去动态加载
* 已经加载的类会被放在 `ClassLoader` 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载

### JVM的类加载器

* **`BootstrapClassLoader`(启动类加载器)** ：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）
* **`ExtensionClassLoader`(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
* **`AppClassLoader`(应用程序类加载器)** ：面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。


* 除了 `BootstrapClassLoader` 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 `ClassLoader`抽象类。
* 这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类

## 双亲委派模型

* `ClassLoader` 类使用委托模型来搜索类和资源。
* 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
* `ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。

![1763615700937](https://file+.vscode-resource.vscode-cdn.net/d%3A/GitHub/ycc/JavaGuide/Java/JVM/image/%E4%BA%8C%E5%93%A5+JavaGuide/1763615700937.png)

### 双亲委派模型执行过程

* 在类加载的时候，首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。
* 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。
* 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。
* 如果子类加载器也无法加载这个类，那么它会抛出一个 `ClassNotFoundException` 异常。


* 判断两个类是否相同：
  * 类的全名是否相同
  * 类的加载器是否一样

### 双亲委派模型的好处

* 避免类的重复加载和防止核心 API 被篡改
