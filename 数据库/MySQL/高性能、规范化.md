# 数据库命名规范

* 对象名称必须使用小写字母并用下划线分割。
* 对象名称禁止使用 MySQL 保留关键字
* 对象的命名要能做到见名识义，并且最好不要超过 32 个字符。
* 临时库表必须以 `tmp_` 为前缀并以日期为后缀，备份表必须以 `bak_` 为前缀并以日期 (时间戳) 为后缀。
* 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。

# 数据库基本设计规范

* 无特殊情况，所有表必须使用 **InnoDB** 引擎
* 字符集统一使用 **UTF-8**
* 所有表和字段都需要添加注释
* 单表数据量建议控制在500万以内
  * 可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小
* 谨慎使用 MySQL 分区表
  * 分区表：物理上表现为多个文件，逻辑上表现为一个表
  * 建议使用物理分区表管理大数据
* 经常一起用的列放一个表中
* 禁止在表中建立预留字段
* 禁止存储文件等大型二进制数据
* 不必拘泥于第三范式
* 禁止线上做数据库压测

# 数据库字段设计规范

* 优先选择符合存储需要的最小数据类型
  * 字符串可以转换为数字，如 **IP** 地址
  * 非负型数据，优先使用无符号整型存储
  * 小数值优先使用 **TINYINT** 类型
* 避免使用 TEXT、BLOB 数据类型
* 避免使用 ENUM 类型
* 尽可能把所有列都定义为 NOT NULL
  * 索引 NULL 列需要额外的空间来保存，所以要占用更多的空间
  * 进行比较和计算时要对 NULL 值做特别的处理
* 不允许使用字符串存储日期，而是用 DATETIME TIMESTAMP 或 数值型时间戳
* 单表不要包含过多字段

# 索引设计规范

* 每张表索引数量不要超过五个

  * 索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率
* 禁止使用全文索引
* 禁止给表中的每一个列都建立索引
* 每个InnoDB表都必须有主键

  * 不要使用更新频繁的列作为主键，不使用多列主键
  * 不要使用 UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。
  * 主键建议使用自增 ID 值。
* 索引列建议

  * 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列。
  * 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段。
  * 不要将符合 1 和 2 中的字段的列都建立一个索引，通常将 1、2 中的字段建立联合索引效果更好。
  * 多表 join 的关联列。


# 数据库开发规范

* 尽量不在数据库做运算
* 优化对性能影响较大的SQL语句
* 充分利用表上已经存在的索引
* 禁止直接 SELECT *
* 禁止用不含字段列表的 INSERT 语句
  * 反例：`insert into t values ('a','b','c');`
  * 正例：`insert into t(c1,c2,c3) values ('a','b','c');`
* 使用预编译语句进行数据库操作
* 避免数据类型隐式转换，否则会导致索引失效
* 避免使用子查询，而是改为 join 操作
  * 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引
* 避免用 JOIN 关联太多的表
* 减少和数据库的交互次数
* 禁止使用 order by rand() 进行随机排序
* WHERE 从句中禁止对列进行函数转换和计算
  * 反例：`where date(create_time)='20190101'`
  * 正例：`where create_time >= '20190101' and create_time < '20190102'`
* 明显没有重复值是使用 UNION ALL 查询
  * UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作。
  * UNION ALL 不会再对结果集进行去重操作。
* 将复杂的 SQL 查询拆分成多个 SQL 查询

# 数据库操作行为规范

* 超过100万行的批量写要分批进行
*
