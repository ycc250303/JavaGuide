# SQL基础语法

## SQL语法

### SQL语法结构

![1768194827002](image/JavaGuide/1768194827002.png)

SQL 语法结构包括：

* **`子句`** - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）
* **`表达式`** - 可以产生任何标量值，或由列和行的数据库表
* **`谓词`** - 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。
* **`查询`** - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。
* **`语句`** - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。

## 子查询

子查询常用在 `WHERE` 子句和 `FROM` 子句后边：

```sql
select column_name [, column_name ]
from   table1 [, table2 ]
where  column_name operator
    (select column_name [, column_name ]
    from table1 [, table2 ]
    [where])
```

```sql
select column_name [, column_name ]
from (select column_name [, column_name ]
      from table1 [, table2 ]
      [where]) as temp_table_name
where  condition
```

## 连接

### **join ON 和 WHERE 的区别**

* 连接表时，SQL 会根据连接条件生成一张新的临时表。`ON` 就是连接条件，它决定临时表的生成。
* `WHERE` 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。

所以总结来说就是： **SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选** 。

## 组合

`UNION` 基本规则：

* 所有查询的列数和列顺序必须相同。
* 每个查询中涉及表的列的数据类型必须相同或兼容。
* 通常返回的列名取自第一个查询。
* 默认地，`UNION` 操作符选取不同的值。如果允许重复的值，请使用 `UNION ALL`

`JOIN` vs `UNION`：

* `JOIN` 中连接表的列可能不同，但在 `UNION` 中，所有查询的列数和列顺序必须相同。
* `UNION` 将查询之后的行放在一起（垂直放置），但 `JOIN` 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。

## 索引

## 约束

## 事务处理

不能回退 `SELECT` 语句，回退 `SELECT` 语句也没意义；也不能回退 `CREATE` 和 `DROP` 语句。

 **MySQL 默认是隐式提交** ，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 `START TRANSACTION` 语句时，会关闭隐式提交；当 `COMMIT` 或 `ROLLBACK` 语句执行后，事务会自动关闭，重新恢复隐式提交。

指令：

* `START TRANSACTION` - 指令用于标记事务的起始点。
* `SAVEPOINT` - 指令用于创建保留点。
* `ROLLBACK TO` - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 `START TRANSACTION` 语句处。
* `COMMIT` - 提交事务。

## 权限控制

# MySQL

## MySQL字段类型

### 整数类型unsigned作用

* 不允许负值的无符号整数。使用 UNSIGNED 属性可以将正整数的上限提高一倍
* 对于从 0 开始递增的 ID 列，使用 UNSIGNED 属性可以非常适合

### varchar(10)和varchar(100)

* 二者存储相同的字符串，所占用磁盘的存储空间其实是一样的
* VARCHAR(100) 会消耗更多的内存。这是因为 VARCHAR 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。

### decimal和float/double

* DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT/DOUBLE 只能存储近似的小数值。
* DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。

### datetime和timestamp

* DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。
* TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间。
* Timestamp 表示的时间范围更小。

### NULL和''

* 含义

  * `NULL` 代表一个不确定的值，它不等于任何值，包括它自身。因此，`SELECT NULL = NULL` 的结果是 `NULL`，而不是 `true` 或 `false`。
  * `NULL` 意味着缺失或未知的信息。虽然 `NULL` 不等于任何值，但在某些操作中，数据库系统会将 `NULL` 值视为相同的类别进行处理，例如：`DISTINCT`,`GROUP BY`,`ORDER BY`。
  * 需要注意的是，这些操作将 `NULL` 值视为相同的类别进行处理，并不意味着 `NULL` 值之间是相等的。 它们只是在特定操作中被特殊处理，以保证结果的正确性和一致性。 这种处理方式是为了方便数据操作，而不是改变了 `NULL` 的语义。
  * `''` 表示一个空字符串，它是一个已知的值。
* 比较运算
* * 任何值与 `NULL` 进行比较（例如 `=`, `!=`, `>`, `<` 等）的结果都是 `NULL`，表示结果不确定。要判断一个值是否为 `NULL`，必须使用 `IS NULL` 或 `IS NOT NULL`。
  * `''` 可以像其他字符串一样进行比较运算。例如，`'' = ''` 的结果是 `true`。
* 聚合函数：

  * 大多数聚合函数（例如 `SUM`, `AVG`, `MIN`, `MAX`）会忽略 `NULL` 值。
  * `COUNT(*)` 会统计所有行数，包括包含 `NULL` 值的行。`COUNT(列名)` 会统计指定列中非 `NULL` 值的行数。
  * 空字符串 `''` 会被聚合函数计算在内。例如，`SUM` 会将其视为 0，`MIN` 和 `MAX` 会将其视为一个空字符串

### MySQL没有boolean类型，使用 `tinyint`表示

### 手机号存储用 int 还是 varchar

**推荐使用varchar**

![1760406307805](image/JavaGuide/1760406307805.png)

## MySQL基础架构

* MySQL 可以简单分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取，MySQL 支持 InnoDB、MyISAM、Memory 等多种存储引擎。

![1760406377049](image/JavaGuide/1760406377049.png)

* 主要构成：
  * **连接器：** 身份认证和权限相关(登录 MySQL 的时候)。
  * **查询缓存：** 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
  * **分析器：** 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
  * **优化器：** 按照 MySQL 认为最优的方案去执行。
  * **执行器：** 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。
  * **插件式存储引擎** ：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。InnoDB 是 MySQL 的默认存储引擎，绝大部分场景使用 InnoDB 就是最好的选择。

### Server层

主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。

* 连接器：进行用户的身份认证，包括校验账户密码，权限等操作。后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的
* 查询缓存
* 分析器：
  * 词法分析：提取关键字，如select、表、字段名等
  * 语法分析：判断SQL语句是否正确

## SQL语句在MySQL的执行过程

### 查询语句

```sql
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
```

* 查询语句的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎
  * 查询权限
  * （MySQL 8.0 之前）查询缓存
  * 分析器、优化器
  * 进行权限校验，如果没有权限就会返回错误信息
  * 如果有权限就会调用数据库引擎接口，返回引擎的执行结果。

### 更新语句

* 更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit 状态)

## MySQL存储引擎

* **存储引擎是基于表的，而不是数据库，可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要**

### MyISAM和InnoDB区别

|                 维度                 | MyISAM                                                  | InnoDB                                                 |
| :----------------------------------: | ------------------------------------------------------- | ------------------------------------------------------ |
|             **锁**             | 只有表级锁，上锁就锁住了整张表                          | 有表级锁和行级锁，默认行级锁                           |
|            **事务**            | 不提供事务支持                                          | 提供支持并定义了四个隔离级别                           |
|            **外键**            | 不支持                                                  | 支持                                                   |
| **数据库异常崩溃后的安全恢复** | 不支持                                                  | 支持，依赖于 `redo log`                              |
|       **是否支持 MVCC**       | 不支持                                                  | 支持                                                   |
|          **索引实现**          | 索引文件和数据文件是分离的                              | 数据文件本身就是索引文件                               |
|            **性能**            | 读写不能并发                                            | 随着 CPU 核数的增加，<br />InnoDB 的读写能力呈线性增长 |
|   **数据缓存策略和机制**实现   | 使用键缓存（Key Cache）<br />仅缓存索引页而不缓存数据页 | 使用缓冲池（Buffer Pool）<br />缓存数据页和索引页      |

## MySQL日期选择

* **不要使用字符串**
  * 占用更多内存
  * 查询和计算效率低

### DateTime和TimeStamp

* 前者没有时区信息，后者有

```sql
# 查看当前会话时区
SELECT @@session.time_zone;
# 设置当前会话时区
SET time_zone = 'Europe/Helsinki';
SET time_zone = "+00:00";
# 数据库全局时区设置
SELECT @@global.time_zone;
# 设置全局时区
SET GLOBAL time_zone = '+8:00';
SET GLOBAL time_zone = 'Europe/Helsinki';
```

* `DateTime `的范围是 5-8 字节，`TIMESTAMP `的范围是 4-7 字节。
* `TIMESTAMP`只能到2038年，`DateTime`能到9999年
* `TIMESTAMP`需要时区转换、有额外开销。

  * 推荐的做法是在应用程序层面统一管理时区，或者在数据库连接/会话级别显式设置 `time_zone` 参数，而不是依赖服务器的默认或操作系统时区。
* `TIMESTAMP` ：多时区
* `DATETIME`：不涉及时区，需要2038年后
* 时间戳：极度需求性能，接受可读性牺牲

![1760579796145](image/JavaGuide/1760579796145.png)
