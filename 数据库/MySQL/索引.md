# MySQL索引

## 优缺点

* 优点
  * 提高查询速度
  * 保证数据唯一性：唯一索引
  * 加速排序和分组：`order by`和 `group by`
* 缺点
  * 创建、维护耗时
  * 占用存储空间
  * 设计不当**可能被误用或失效**
* 索引不一定能提高查询性能
  * 数据量太小
  * 查询结果集占比过大（比如超过20%-30%），优化器可能会认为全表扫描更划算
  * 索引维护不当

## 索引数据结构选择

## 不用哈希

* **不支持范围查询（主要）**：相邻的值会被映射到哈希表不相邻的位置
* **不支持排序**：哈希值无序
* **不支持部分索引键查询**：哈希值必须使用所有索引列进行查询
* **哈希冲突**：当不同的键产生相同的哈希值时，需要额外的链表或开放寻址来解决，这会降低性能

## 不用B树

* **I/O 效率更高:** B+树只有叶子节点才存储数据（或数据指针），而非叶子节点只存储索引键。因为非叶子节点不存数据，所以它们可以容纳更多的索引键。这意味着 B+树的“扇出”更大，**在同样的数据量下，B+树通常会比 B 树更矮，也就意味着查找数据所需的磁盘 I/O 次数更少。**
* **查询性能更稳定:** B+树中，任何一次查询都必须从根节点走到叶子节点才能找到数据，所以**查询路径的长度是固定的**。而在 B 树中，如果运气好，可能在非叶子节点就找到了数据，但运气不好也得走到叶子，这导致查询性能不稳定。
* **对范围查询极其友好:** B+树**的所有叶子节点之间通过一个双向链表连接**。当我们执行一个范围查询（比如 `WHERE id > 100`）时，只需要通过树形结构找到 `id=100` 的叶子节点，然后就可以沿着链表向后顺序扫描，而无需再回溯到上层节点。这使得范围查询的效率大大提高。

## MyISAM和InnoDB索引区别

* MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“ **非聚簇索引（非聚集索引）** ”。
* InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“ **聚簇索引（聚集索引）** ”，而其余的索引都作为  **辅助索引** ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。
* 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

## 索引类型

按照应用维度划分：

* 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
* 普通索引：仅加速查询。
* 唯一索引：加速查询 + 列值唯一（可以有 NULL）。
* 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。
* 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
* 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR`、`TEXT` 列上可以创建全文索引。一般不会使用，效率较低。
* 前缀索引：对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。

MySQL 8.x 中实现的索引新特性：

* 隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。
* 降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。
* 函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。

### 聚集索引和非聚集索引

* 聚集索引优缺点：
  * 优点：
    * **查询速度非常快**
    * **对排序查找和范围查找优化**
  * 缺点：
    * **依赖于有序的数据**
    * **更新代价大**
* 非聚集索引优缺点：
  * 优点：

    * 更新代价比聚簇索引要小
  * 缺点：

    * **依赖于有序的数据**
    * **可能会二次查询（回表）** ：当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

## 最左前缀匹配

* MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。
* 最左匹配原则会一直向右匹配，直到遇到范围查询（如 >、<）为止。对于 >=、<=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配
* 如果有索引 `联合索引（a，b，c）`，查询 `a=1 AND c=1` 会走索引么？`c=1` 呢？`b=1 AND c=1` 呢？ `b = 1 AND a = 1 AND c = 1` 呢？
  * 查询 `a=1 AND c=1`：会，根据最左前缀匹配原则，查询可以使用索引的前缀部分。因此，该查询仅在 `a=1` 上使用索引，然后对结果进行 `c=1` 的过滤。
  * 查询 `c=1`：不会，由于查询中不包含最左列 `a`，根据最左前缀匹配原则，整个索引都无法被使用。
  * 查询 `b=1 AND c=1`：不会，和第二种一样的情况，整个索引都不会使用。
  * 查询 `b=1 AND a=1 AND c=1`：会。查询优化器分析 SQL 语句时，对于联合索引，会对查询条件进行重排序，以便用到索引。会将 `b=1` 和 `a=1` 的条件进行重排序，变成 `a=1 AND b=1 AND c=1`。

## 索引下推

### 介绍

* **索引下推（Index Condition Pushdown，简称 ICP）** 允许存储引擎在索引遍历过程中，执行部分 `WHERE` 字句的判断条件，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率。
* 将部分上层（Server 层）负责的事情，交给了下层（存储引擎层）去处理。

![1760499240704](image/JavaGuide/1760499240704.png)

### 实例

```sql
CREATE TABLE `user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `username` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `zipcode` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `birthdate` date NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_username_birthdate` (`zipcode`,`birthdate`) ) ENGINE=InnoDB AUTO_INCREMENT=1001 DEFAULT CHARSET=utf8mb4;

# 查询 zipcode 为 431200 且生日在 3 月的用户
# birthdate 字段使用函数索引失效
SELECT * FROM user WHERE zipcode = '431200' AND MONTH(birthdate) = 3;
```

没有索引下推之前：

* 存储引擎层先根据 `zipcode` 索引字段找到所有 `zipcode = '431200'` 的用户的主键 ID，然后二次回表查询，获取完整的用户数据；
* 存储引擎层把所有 `zipcode = '431200'` 的用户数据全部交给 Server 层，Server 层根据 `MONTH(birthdate) = 3` 这一条件再进一步做筛选。

有了索引下推之后：

* 存储引擎层先根据 `zipcode` 索引字段找到所有 `zipcode = '431200'` 的用户，然后直接判断 `MONTH(birthdate) = 3`，筛选出符合条件的主键 ID；
* 二次回表查询，根据符合条件的主键 ID 去获取完整的用户数据；
* 存储引擎层把符合条件的用户数据全部交给 Server 层。

**除了可以减少回表次数之外，索引下推还可以减少存储引擎层和 Server 层的数据传输量。**

### 适用范围

* 适用于 InnoDB 引擎和 MyISAM 引擎的查询。
* 适用于执行计划是 range、ref、eq_ref、ref_or_null 的范围查询。
* 对于 InnoDB 表，仅用于非聚簇索引。索引下推的目标是减少全行读取次数，从而减少 I/O 操作。对于 InnoDB 聚集索引，完整的记录已经读入 InnoDB 缓冲区。在这种情况下使用索引下推不会减少 I/O。
* 子查询不能使用索引下推，因为子查询通常会创建临时表来处理结果，而这些临时表是没有索引的。
* 存储过程不能使用索引下推，因为存储引擎无法调用存储函数。

## 索引使用建议

* 字段选择

  * **字段不为null**
  * **为常作为查询条件、排序、分组(where、order by、group by)的字段建立索引**
* 被频繁更新的字段，慎重建立索引
* 每张表索引数量不要超过5个

  * MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。
* 尽量考虑联合索引而非单列

  * 如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。
* 避免冗余索引
* 字符串类型，使用前缀索引
* 避免索引失效

  * ~使用 `SELECT *` 进行查询;~ `SELECT *` 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖；
  * 创建了组合索引，但查询条件未遵守最左匹配原则；
  * 在索引列上进行计算、函数、类型转换等操作；
  * 以 % 开头的 LIKE 查询比如 `LIKE '%abc';`；
  * 查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到；
  * IN 的取值范围较大时会导致索引失效，走全表扫描（NOT IN 和 IN 的失效场景相同）；
  * 发生[隐式转换](https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html)；

## 分析SQL是否使用索引

`explain`
