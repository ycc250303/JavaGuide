
# 数据库原理与应用

## 2 关系模型介绍

### 2.1 关系数据库的结构

* 表：关系数据库的构成单位
* 关系：指代表
* 元组：指代表的行
* 属性：指代表的列
* 关系实例：指代一个关系的特定实例
* 域：关系的每个属性允许取值的集合
* 原子域：域中不包含子集的域
* 空值（null）：表示未知或不存在

### 2.2 数据库模式

* 数据库模式：数据库的逻辑设计
* 数据库实例：在给定数据库中数据的一个快照
* 关系模式：对应于程序设计语言中类型定义的概念

### 2.3 码

* 码
  * 超码：一个或多个属性的集合，将这些组合集合组合在一起能够在一个关系中唯一地标识出元组。
  * 候选码：最小的超码，它的任意真子集都不是超码。
  * 主码：在一个关系中区分不同元组的候选码，应该选择其值不会变化或极少变化的属性。
  * 主码约束：关系中的任意两个不同元组都不允许同时在码属性上具有相同的值
* 外码约束
  * 外码
  * 引用关系
  * 被引用关系
* 引用完整性约束

### 2.4 模式图

* 模式图：带有主码和外码约束的数据库模式可以用模式图表示
![alt text](figures\ch2_01.png)

### 2.5 关系查询语言

* 查询语言模型
  * 命令式：用户指导系统在数据库上执行特定的运算序列计算出所需的结果
  * 函数式：计算被表示为对函数的求值
  * 声明式：用户只需描述所需信息，而不需要给出获取该信息的具体步骤序列或函数调用

### 2.6 关系代数

* 关系代数：由一组运算组成，这些运算接受一个或两个关系作为输入，并生成一个新的关系作为运算结果。

#### 2.6.1 选择运算

* 选出满足给定谓词的元组
* 允许在选择谓词中使用逻辑判断进行比较，使用联接词组合谓词

$\sigma$<sub>属性名</sub> = <span style="position: relative; bottom: -0.5em;">条件</span>(表名)

#### 2.6.2 投影运算

$\Pi$<sub>属性集合</sub>(表名)

* 选择关系中的一部分属性，过滤掉特定的属性

#### 2.6.3 关系运算复合

* 关系代数表达式：关系代数运算复合在一起

#### 2.6.4 笛卡尔积运算

#### 2.6.5 连接运算

#### 2.6.6 集合运算

#### 2.6.7 赋值运算

#### 2.6.8 更名运算

* 返回以x命名的关系表达式E的结果
  
$\rho$<sub>x</sub>($E$)

#### 2.6.9 等价查询

## 3 SQL介绍

### 3.1 SQL 数据定义

#### 3.1.1 基本类型

| 数据名称               | 数据类型                                           |
| :--------------------- | :------------------------------------------------- |
| char(n)                | 定长字符串                                         |
| varchar(n)             | 变长字符串                                         |
| int                    | 整数                                               |
| smallint               | 小整数                                             |
| numeric(p,d)           | 指定精度的定点数</br> p位数字，小数点右边可以有d位 |
| real，double precision | 浮点数与双精度浮点数                               |
| float(n)               | 精度至少位n的浮点数                                |

#### 3.1.2 基本模式定义

```sql
-- 定义表结构
create table table_name (
    column_name1 data_type [constraint] [comment 注释],
    column_name2 data_type [constraint] [comment 注释],
    ...
    <约束1>,
    <约束2>,
    ...
);

-- 删除表
drop table table_name;

-- 删除表中所有数据
delete from table_name;

-- 为表中增加属性
alter table table_name add column_name data_type [constraint];

-- 删除表中属性
alter table table_name drop column column_name;
```

#### 3.1.1 完整性约束
  
| 约束类型            | 描述                                       |
| ------------------- | ------------------------------------------ |
| 主键（Primary Key） | 主键约束，保证每行数据的唯一性             |
| 唯一（Unique）      | 唯一约束，保证列或组合列的唯一性           |
| 检查（Check）       | 检查约束，保证列的值满足一定条件           |
| 外键（Foreign Key） | 外键约束，保证表之间的参照完整性           |
| 非空（Not Null）    | 非空约束，保证列的值不为NULL               |
| 默认（Default）     | 默认值，当插入数据时未指定值时，使用默认值 |

### 3.2 查询的基本结构

```sql
-- 单关系查询
select column_name1, column_name2,...
from table_name;

-- distinct/all 去重/不去重
select distinct/all column_name1 
from table_name;

-- 多关系查询
select column_name1, column_name2,...
from table_name1, table_name2;

-- 条件查询
select column_name1, column_name2,...
from table_name
where condition;

-- 排序查询
select column_name1, column_name2,...
from table_name
order by column_name1, column_name2;
```

#### 3.2.1 附加的基本运算

```sql
-- 更名运算
select column_name1 as new_column_name1, column_name2 as new_column_name2,...
from table_name as new_table_name;

-- 字符串运算
-- % 表示任意字符
-- _ 表示一个字符
-- || 表示字符串连接
-- \ 表示转义字符

select column_name1 || column_name2 as new_column_name
from table_name
where column_name1 like 'pattern%';

-- 查找所有属性
select * 
from table_name;
```

### 3.3 集合运算

```sql
-- 并集 union
select column_name1, column_name2,...
from table_name1
union
select column_name1, column_name2,...
from table_name2;

-- 交集 intersect
select column_name1, column_name2,...
from table_name1
intersect
select column_name1, column_name2,...
from table_name2;

-- 差集 except
select column_name1, column_name2,...
from table_name1
except
select column_name1, column_name2,...
from table_name2;
```

### 3.4 空值与unknown

```sql
-- 空值
select column_name1, column_name2,...
from table_name
where column_name is null;

-- unknown
select column_name1, column_name2,...
from table_name
where column_name is unknown;
```

* and运算结果(优先级：false>unknown>true)

| and     | true    | false | unknown |
| :------ | :------ | :---- | :------ |
| true    | true    | false | unknown |
| false   | false   | false | false   |
| unknown | unknown | false | unknown |

* or运算结果(优先级：true>unknown>false)

| or      | true | false   | unknown |
| :------ | :--- | :------ | :------ |
| true    | true | true    | true    |
| false   | true | false   | unknown |
| unknown | true | unknown | unknown |

### 3.5 聚集函数

```sql
-- 基本聚集
-- 平均值
select avg(column_name) as avg_column_name
from table_name;

-- 最大值   
select max(column_name) as max_column_name
from table_name;

-- 最小值
select min(column_name) as min_column_name
from table_name;

-- 总和
select sum(column_name) as sum_column_name
from table_name;

-- 计数
select count(column_name) as count_column_name
from table_name;
```

```sql
-- 分组
select column_name1, column_name2, avg(column_name3) as avg_column_name3
from table_name
group by column_name1, column_name2;

-- 出现在 select 子句中但是没有被聚集的属性只能是出现在 group by 子句中的属性

-- 错误查询
select column_name1, column_name2, column_name3
from table_name
group by column_name1, column_name2;
```

#### 3.5.1 having子句

```sql
-- having子句
-- 针对group by 子句的结果进行过滤
select column_name1, column_name2, avg(column_name3) as avg_column_name3
from table_name
group by column_name1, column_name2
having avg_column_name3 > 100;

select column from table_name [where condition] group by column [having condition]
```

* where 和 having 的区别
  * 执行时机不同：where对分组前的数据进行过滤，不满足条件的组不会被计算；having对分组后的数据进行过滤，不满足条件的组会被过滤掉。
  * 判断条件不同：where不能对聚合函数进行判断，但是having可以。

### 3.6 嵌套子查询

#### 3.6.1 集合成员资格

```sql
select column_name1, column_name2
from table_name1
where column_name1 in (select column_name1 from table_name2);

select column_name1, column_name2
from table_name1
where column_name1 not in (a,b);
```

#### 3.6.2 集合比较

```sql
select column_name1, column_name2
from table_name1
where column_name1 = (select column_name1 from table_name2 where column_name2 = 'value');

select column_name1, column_name2
from table_name1
where column_name1 < some(select column_name1 from table_name2 where column_name2 = 'value');

-- =some等价于in，但<>some不等价于not in
-- <>all等价于not in，但=all不等价于in
```

#### 3.6.3 空关系测试

```sql
select column_name1, column_name2
from table_name1
where [not] exists (select * from table_name2 where column_name2 = 'value');
```

#### 3.6.4 重复元组存在测试

```sql
select column_name1, column_name2
from table_name1
where column_name1 in (select column_name1 from table_name2 group by column_name1 having count(*) > 1);

select column_name1, column_name2
from table_name1
where unique (select column_name1 from table_name2 where column_name2 = 'value');

select column_name1, column_name2
from table_name1
where 1 >= (select column_name1 from table_name2 where column_name2 = 'value');
```

#### 3.6.5 from子句的嵌套子查询

```sql
select dept_name,avg_salary
from (select dept_name,avg(salary) as avg_salary
      from instructor
      group by dept_name)
where avg_salary > 50000;
```

#### 3.6.6 with字句

```sql
-- 创建临时关系，与from等价，但更简洁
with cte_name(value1, value2) as (
    select column_name1, column_name2
    from table_name
)
select column_name1, column_name2
from cte_name;
```

#### 3.6.7 标量子查询

* 子查询返回一个包含单个属性的元组

```sql
select column_name1, (select count(*) from table_name2 where column_name1 = table_name1.column_name1)
from table_name1;
```

### 3.7 数据库修改

#### 删除

```sql
-- 删除表
drop table table_name;

-- 删除表中所有数据
delete from table_name;

-- 删除表中属性c
alter table table_name drop column column_name;

delete from table_name where condition;
```

#### 插入

```sql
-- 插入数据
insert into table_name (column_name1, column_name2,...)
values (value1, value2, ...);

-- 插入多条数据
insert into table_name (column_name1, column_name2,...)
values (value1, value2, ...),
       (value1, value2, ...),
       ...;

-- 插入子查询
insert into table_name (column_name1, column_name2,...)
select column_name1, column_name2, ...
from table_name2;
```

#### 更新

```sql
-- 更新数据
update table_name
set column_name1 = value1, column_name2 = value2, ...
where condition;

-- 更新多条数据
update table_name
set column_name1 = value1, column_name2 = value2, ...
where condition1
union
select column_name1, column_name2, ...
from table_name2
where condition2;

-- 更新子查询
update table_name
set column_name1 = (select column_name1 from table_name2 where column_name2 = 'value');
```

## 4.中级SQL

### 4.1 连接表达式

#### 4.1.1 自然连接

* 只考虑在两个关系的模式中都出现的属性上取值相同的元组对

```sql
select column_name1, column_name2
from table_name1, table_name2
where table_name1.column_name1 = table_name2.column_name2;

select column_name1, column_name2
from table_name1
natural join table_name2;

-- 列出学生姓名以及所选课程
select name,title 
from student natural join takes,course
where course.course_id = takes.course_id;

-- 错误查询
select name,title 
from student natural join takes natural join course;

-- 指定相等的列
select name,title 
from (student natural join takes) course using (course_id)

-- 指定连接条件
select *
from student join takes on student.student_id = takes.student_id;

select *
from student,takes
where student.student_id = takes.student_id;
```

#### 4.1.2 外连接

```sql
-- 左外连接
-- 只保留出现在左外连接运算之前的关系中的元组
select *
from student natural left outer join takes;

-- 右外连接
-- 只保留出现在右外连接运算之后的关系中的元组
select *
from takes natural right outer join student;

-- 全外连接
-- 保留出现在两个关系中的元组
select * 
from (select *
      from student
      where dept_name = 'Comp. Sci.')
      natural full outer join
      (select *
      from takes 
      where course_id = 'CS101' and semester = 'Spring');

-- on 和 where 区别
-- on 用于连接条件，where 用于过滤条件
-- 下面两个查询不等价
select *
from student left outer join takes on student.ID = takes.ID


select *
from student left outer join takes on true
where takes.ID = student.ID;

-- 内连接
-- 仅保留出现在两个关系中的元组
select *
from student inner join takes on student.ID = takes.ID;

select *
from student inner join takes using (ID);
```

### 4.2 视图

```sql
-- 创建视图
create view v as <查询表达式>;

create view faculty as 
    select ID,name,dept_name
    from instructor;

-- 指定属性名
create view depaetments_total_salary(dept_name,total_salary) as
    select dept_name,sum(salary)
    from instructor
    group by dept_name;
```

* 物化视图：定义视图的实际关系发生改变，视图也跟着修改以保持最新。

**可更新的**视图需要满足的条件：

* from 子句中只有一个数据库关系
* select 子句中只包含关系属性名，不包含任何表达式，聚集或 distinct 声明
* 没有出现在 select 子句中的任何属性都可以取 null 值（没有非空约束，不构成主码的一部分）
* 查询中不含有 group by 或 having 子句

* 在视图定义末尾加入`with check option`，会拒绝插入不满足where子句的条件的元组。

### 4.3 事务

事务的四个属性：

* 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做
* 一致性（Consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态
* 隔离性（Isolation）：一个事务的执行不能被其他事务干扰
* 持久性（Durability）：一个事务一旦提交，它对数据库中数据的改变就应该永久保存

```sql
-- 开启事务
begin;

-- 提交事务
commit work;

-- 回滚事务
rollback work;

-- 关闭自动提交
set autocommit off;

-- 构成事务
begin atomic ... end
```

### 4.4 完整性约束

允许的完整性约束包括：

* primary key
* foreign key
* not null
* unique(允许为null值)
* check(<谓词>)
* ...

#### 4.4.1 引用完整性

* 被指定的属性列表必须声明为被引用关系的超码

```sql
foreign key (dept_name) references department (dept_name)

-- 创建外键
alter table table_name add constraint foreign_key_name foreign key (column_name) references table_name (column_name)

-- 级联删除：当删除父表中的元组时，同时删除子表中的元组
-- 级联更新：当更新父表中的元组时，同时更新子表中的元组
-- 命名约束
create table instructor (
  salary numeric(8,2),constraint min_salary check (salary > 0),
  ...
  foreign key (dept_name) references department
              on delete cascade 
              on update cascade,
  ...
)

-- 删除约束
alter table instructor drop constraint min_salary;

-- 延迟约束：在提交事务之前，不检查约束
set constraints constraint_name deferred;
```

| 行为                   | 说明                                                                                                            |
| ---------------------- | --------------------------------------------------------------------------------------------------------------- |
| ``no action/restrict`` | 在父表中删除/更新记录时</br>首先检查是否有对应外键</br>如果有则不允许删除/更新                                  |
| ``cascade``            | 在父表中删除/更新记录时</br>首先检查是否有对应外键</br>如果有则也删除/更新外键在子表中的记录                    |
| ``set null``           | 在父表中删除记录时</br>首先检查是否有对应外键</br>如果有则将子表中的对应外键设置为null                          |
| ``set default``        | 在父表中删除/更新记录时</br>首先检查是否有对应外键</br>如果有则将子表中的对应外键设置为一个默认值(Innodb不支持) |

#### 4.4.2 复杂约束与断言

```sql
-- 复杂约束
check (time_slot_id in (select time_slot_id from time_slot));

-- 断言
create assertion <assertion_name> check <predicate>;

-- coalesce函数
-- 寻找第一个非空元素
create assertion credits_earned_constraint check
(not exists (select ID
             from student
             where tot_cred <> (select coalesce(sum(credits),0))
                                from takes natural join course
                                where student.ID = takes.ID
                                      and grade is not null and grade <> 'F'));

create assertion no_different_classroom_same_time check
(
  not exists (select ID,name,course_id,sec_id,year,time_slot_id
              count(room_number,building)
              where (section natural join teaches) join insturctor using(ID)
              group by ID,name,course_id,sec_id,year,time_slot_id
              having count(room_number,building)>1)
);

-- 删除断言
drop assertion credits_earned_constraint;
```

### 4.5 SQL 数据类型与模式

#### 4.5.1 日期和时间类型

| 数据类型  | 描述   | 说明                  |
| --------- | ------ | --------------------- |
| date      | 日期   | '2018-04-25'          |
| time      | 时间   | '09:30:00'            |
| timestamp | 时间戳 | '2018-04-25 09:30:00' |

| 函数                           | 描述                   |
| ------------------------------ | ---------------------- |
| current_date                   | 返回当前日期           |
| current_time                   | 返回当前时间           |
| current_timestamp              | 返回当前时间戳         |
| extract (field from timestamp) | 从时间戳中提取指定字段 |

#### 4.5.2 类型转换与格式化函数

```sql
-- 类型转换
cast (e as t)

-- 格式化函数
to_char(e, format)
to_number(e, format)
to_date(e, format)

-- coalesce
-- 从左到右返回第一个非空值，如果所有值都为空，则返回null
coalesce(e1,e2,...,en)

-- 解码
-- 将value值与match值匹配，如果成功则用replacement值替换，否则用default_replacement值替换
decode(value , match_1 , replacement_1 , 
               match_2 , replacement_2 , 
               ... , 
               match_n , replacement_n ,
               default_replacement)

```

#### 4.5.3 自定义数据类型

独特类型和结构化数据类型

```sql
-- 自定义类型
create type Dollars as numeric(8,2) final;

-- 修改类型
alter type Dollars as numeric(10,2);

-- 删除类型
drop type Dollars;

-- 域：可以在基本类型上施加完整性约束
create domain dollars as numeric(8,2) check (value >= 0);

create domain yaerSalary numeric(8,2) constraint salary_value_test check(value>=10000);
```

#### 4.5.4 生成唯一码值

```sql
-- 此时insert语句需要指定ID值
-- always语句能避免insert语句为自动生成的码指定一个值
ID number(5) generated always as identity;
```

* MySQL中用`auto_increment`来生成唯一码值

#### 4.5.5 create table 拓展

```sql
-- 编写复杂查询时，把查询结果存储成一个新表
create table temp_instrutor like instructor;

create table temp_instrutor as select * from instructor with data;
```

### 4.6 索引定义

* 是一种数据结构，允许数据库系统搞笑查找在关系中具有指定值的元组

```sql
-- 创建索引
create index <索引名> on <关系名>(<属性列表>);

create index index_name on table_name (column_name);

-- 声明搜索码作为候选码（属性列表需要为候选码）
create unique index index_name on table_name (column_name);

-- 删除索引
drop index index_name;
```

### 4.7 授权

* 对数据的授权包括：
  * 授权读取数据
  * 授权插入新数据
  * 授权更新数据
  * 授权删除数据
  
#### 4.7.1 权限授予与收回

```sql
-- 授予权限
grant <权限列表> on <关系名或视图名> to <用户/角色列表>;

grant select on department to Amit;

-- 收回权限
revoke <权限列表> on <关系名或视图名> from <用户/角色列表>;

revoke select on department from Amit;
```

* 对public角色授予权限隐含着对所有当前用户和将来用户的授权
* SQL 不允许在一个关系的特定元组上授权

#### 4.7.2 角色

* 一个角色的所有权限包括：
  * 只接授予该角色的所有权限
  * 授予该角色所拥有的角色的所有权限
  
```sql
-- 创建角色
create role <角色名>;

create role role_name;

-- 授予角色
grant <角色名> to <用户/角色列表>;

grant Amit to role_name;

-- 收回角色
revoke <角色名> from <用户/角色列表>;

revoke Amit from role_name;

-- 删除角色
drop role <角色名>;
```

##### 4.7.3 权限列表

| 权限       | 描述                     |
| ---------- | ------------------------ |
| select     | 允许用户读取关系中的数据 |
| insert     | 允许用户向关系中插入数据 |
| update     | 允许用户更新关系中的数据 |
| delete     | 允许用户删除关系中的数据 |
| truncate   | 允许用户清空关系中的数据 |
| references | 允许用户创建外键约束     |
| trigger    | 允许用户创建触发器       |
| execute    | 允许用户执行存储过程     |
| usage      | 允许用户创建索引         |

#### 4.7.4 视图的授权

```sql
-- 授予用户对视图的访问权限
grant <权限列表> on <视图名> to <用户/角色列表>;

grant select on view_name to Amit;

-- 授予用户对视图所引用的关系的访问权限
grant <权限列表> on <关系名> to <用户/角色列表>;

grant select on department to Amit;

-- 收回用户对视图的访问权限
revoke <权限列表> on <视图名> from <用户/角色列表>;

revoke select on view_name from Amit;

-- 收回用户对视图所引用的关系的访问权限
revoke <权限列表> on <关系名> from <用户/角色列表>;

revoke select on department from Amit;

-- 防止级联收权
revoke select on department from Amit restrict;

-- 需要级联收权
revoke select on department from Amit cascade;
```

#### 4.7.5 模式的授权

1. 授予用户对模式的访问权限

```sql
-- 授予用户对模式的访问权限
grant <权限列表> on <模式名> to <用户/角色列表>;

grant usage on schema_name to Amit;

-- 收回用户对模式的访问权限
revoke <权限列表> on <模式名> from <用户/角色列表>;

revoke usage on schema_name from Amit;
```

2. 授予用户对模式中的关系的访问权限

```sql
-- 授予用户对模式中的关系的访问权限
grant <权限列表> on <模式名>.<关系名> to <用户/角色列表>;

grant select on schema_name.department to Amit;

-- 收回用户对模式中的关系的访问权限
revoke <权限列表> on <模式名>.<关系名> from <用户/角色列表>;

revoke select on schema_name.department from Amit;
```

#### 4.7.6 权限的转移

```sql
-- with grant option 允许被授予权限的用户将权限转移给其他用户
grant select on department to Amit with grant option;

-- 收回权限的转移
revoke grant option for select on department from Amit;
```

## 5 高级SQL

### 5.1 函数和过程

#### 5.1.1 分支和循环

```sql
-- 分支
-- if语句
if condition1 then
    statement1
elseif condition2 then
    statement2
else
    statement_default
end if;

-- case语句
case 
    when condition1 then result1
    when condition2 then result2
    ...
    else result_default
end;

-- 循环
-- while循环
while condition do
    statement
end while;

-- repeat循环
repeat
    statement
until condition;
end repeat;

-- leave:退出循环
-- iterate:迭代循环

-- for循环
for variable in expression1..expression2 loop
    statement
end loop;

-- loop循环
loop
    statement
end loop;
```

#### 5.1.2 声明及调用SQL函数/过程

```sql
-- 声明函数
create function dept_count(dept_name varchar(20))
  returns integer
  begin
  declare d_count integer
    select count(*) into d_count
    from instructor
    where instructor.dept_name = dept_name;
  return d_count;
  end

-- 调用函数
select dept_name,budget,
from department
where dept_count(dept_name) > 10;


-- 返回表的函数
create function instructor_of(dept_name varchar(20))
  return table(
    ID varchar(5),
    name varchar(20),
    dept_name varchar(20)
    salary numeric(8,2)
  )
  return table(
    select ID, name, dept_name,salary
    from instructor
    where instructor.dept_name = instructor_of.dept_name
  );

select * 
from table(instructor_of('Comp. Sci.'));

* 参数类型

| 类型  | 含义                                         | 备注 |
| ----- | -------------------------------------------- | ---- |
| IN    | 该类参数作为输入，也就是需要调用时传入值     | 默认 |
| OUT   | 该类参数作为输出，也就是该参数可以作为返回值 |
| INOUT | 既可以作为输入参数，也可以作为输出参数       |

* declare 声明变量
* set 进行赋值

-- 声明过程
create procedure dept_count(in dept_name varchar(20),out d_count integer)
  begin
    select count(*) into d_count
    from instructor
    where instructor.dept_name = dept_name;
  end
```

#### 5.1.3 handler

* 用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤

```sql
DECLARE handler action HANDLERFOR condition value l, condition value.... statement;
-- handler action
--   CONTINUE: 继续执行当前程序
--   EXIT: 终止执行当前程序
-- condition value
--   sqlstate sqlstate_value:状态码，如 02000
--   sqlwarning:所有以01开头的SQLSTATE代码的简写
--   not found:所有以02开头的SOLSTATE代码的简写
--   sqlexception:所有没有被SOLWARNING 或 not found 捕获的 sqlstate 代码的简写
```

### 5.2 触发器

* 系统自动执行，作为对数据库行修改的连带效果
  * 指明什么时候执行触发器
  * 指明执行触发器时采取的动作
  * 通常不能执行数据库以外的更新

| 触发器类型      | NEW 和 OLD                                             |
| --------------- | ------------------------------------------------------ |
| insert 型触发器 | NEW 表示将要或者已经新增的数据                         |
| update 型触发器 | OLD 表示修改之前的数据，NEW 表示将要或已经修改后的数据 |
| delete 型触发器 | OLD 表示将要或者已经删除的数据                         |

```sql
-- 创建触发器
create trigger trigger_name
before/after insert/update/delete 
[of column_name,...] on table_name 
[referencing old/new row as old_row_name, new_row_name] for each row
when condition
begin
    statement
end;

-- 删除触发器
drop trigger trigger_name;

-- 查看触发器
show triggers;

-- 禁用触发器
alter trigger trigger_name disable;

-- 启用触发器
alter trigger trigger_name enable;
```

* 示例
  
```sql
create trigger timeslot_check1 after insert on section
referencing new row as nrow
for each row
when nrow.time_slot_id not in(
  select time_slot_id 
  from time_slot
)
begin
  rollback;
end;

create trigger credits_earned after update of takes on grade referencing old row as orow, new row as nrow
for each row
when nrow.grade <> 'F' and nrow is not null
  and (orow.grade = 'F' or orow.grade is null)
begin atomic
  update student
  set tot_cred = tot_cred + 
    (select credits
    from course
    where course.course_id = nrow.course_id)
  where student.ID = nrow.ID;
end;
```

#### 5.2.1 不使用触发器的情况

* 复杂的业务逻辑
* 频繁的更新
* 频繁的查询
* 频繁的DDL操作

### 递归查询

#### 使用迭代的传递闭包

```sql
-- create temporary table 用于创建临时表，仅在执行查询的事务内部才可用，并随事务的完成而被删除
create function findAllPrereqs(cid varchar(8))
returns table(course_id varchar(8))
begin
  -- 存储待返回课程的集合
  create temporary table c_prereq(course_id varchar(8));
  -- 包含上一次迭代中找到的课程
  create temporary table new_c_prereq(course_id varchar(8));
  -- 存放中间结果
  create temporary table temp(course_id varchar(8));

  insert into new_c_prereq
    select prereq_id
    from prereq
    where course_id = cid;

  repeat
    insert into c_prereq
      select course_id
      from new_c_prereq;

    insert into temp
      (select prereq.prereq_id
      from prereq,new_c_prereq
      where prereq.course_id = new_c_prereq.course_id)
      except(
        select course_id
        from c_prereq
      );
    delete from new_c_prereq;
    insert into new_c_prereq
      select *
      from temp;
    delete from temp;
  until not exists(select * from new_c_prereq)
  end repeat;
  return table c_prereq;
end;
```

#### SQL中的递归

```sql
with recursive rec_prereq(course_id, prereq_id) as (
  select course_id, prereq_id
  from prereq
union 
  select prereq_id.course_id, prereq.prereq_id
  from rec_prereq, prereq
  where rec_prereq.course_id = prereq.prereq_id
)
select *
from rec_prereq;
```

### 高级聚集特性

#### 排名

```sql

select ID,rank() over (order by (GPA) desc nulls last) as s_rank
from student_grades
order by s_rank;

-- 外层order by将结果按照系名排序，并在各系内部按照名次排序
select ID,dept_name,
  rank() over (partition by dept_name order by (GPA) desc nulls last) as dept_rank
from dept_grades
order by dept_name,dept_rank;
```

#### 旋转

```sql
create table sales(
  item_name varchar(20),
  color varchar(20),
  clothes_size varchar(20),
  quantity int,
);

select *
from sales
pivot(
  sum(quantity) 
  for color in ('red','blue','green')
)
```

## 6 E-R图

### 6.1 设计过程概览

#### 6.1.1 设计阶段

* 分析用户需求
* 选择数据模型
* 抽象数据模型实现->数据库实现
  * 逻辑设计阶段
  * 物理设计阶段

#### 6.1.2 设计选择

需要避免的两个问题：

* 冗余：重复开课导致名称存储冗余
* 不完整：新课程但未开课的信息无法显示

### 6.2 实体-联系模型（E-R模型）

#### 6.2.1 实体集

* **实体**是现实世界中事物的抽象，是数据库中数据的基本单位。现实世界中可以区别于所有其他对象的一个“事务”或“对象”。
* **实体集**是共享相同性质或属性的，具有相同类型的实体的集合。在E-R图中用**矩形**表示。
* 实体通过一组**属性**表示。属性是实体集中每个成员所拥有的描述性性质。

| instructor |
| ---------- |
| <u>ID</u>  |
| name       |
| salary     |

#### 6.2.2 联系集

* **联系**是多个实体间的相互关联。**联系集**是相同类型联系的集合，用**菱形**表示，菱形通过**线条**连接到多个不同的实体集。
* 实体在联系中扮演的功能被称为实体的**角色**。同样的实体集以不同的角色多次参与有关联系集是，需要显示用角色名指明实体如何参与联系实例
* 参与联系集的实体集数目是**联系集**的度。
* 联系集的属性在E-R图中通过**未分割**的矩形来表示，用虚线与菱形链接。

![alt text](figures\ch6_01.png)

![alt text](figures\ch6_09.png)

![alt text](figures\ch6_02.png)

### 6.3 复杂属性

* 简单和复合属性
* 单值和多值属性
* 派生属性

![alt text](figures\ch6_03.png)

### 6.4 映射基数

* 一对一
* 一对多
* 多对一
* 多对多

![alt text](figures\ch6_04.png)

* 通过有向线段(→)表示“一”的约束,指向的部分为**多**的实体集

![alt text](figures\ch6_05.png)

* 全部参与、部分参与：用**双线**表示全部参与

![alt text](figures\ch6_06.png)

* 用数字表示最小和最大关联基数**l..h**,一对一表示为**1..1**。

![alt text](figures\ch6_07.png)

### 6.5 主码

#### 6.5.1 实体集

* 实体的属性取值必须可以**唯一**标识该实体
* 关系模式中**码**的概念适用于实体集

#### 6.5.2 联系集

* 多对多：所有参与实体集的主码的并集
* 一对多/多对一：“多”方的主码是最小的超码
* 一对一：任一参与实体集的主码

#### 6.5.3 弱实体集

* **弱实体集**的存在依赖于另一个实体集，称为其**标识性实体集**，非弱实体集被称为**强实体集**。
* 弱实体集被称为**存在依赖**于标识性实体集，标识性习题集被称为**拥有**它所标识的弱实体集。
* 通过**双边框矩形**表示弱实体集，分辩符加上下划虚线。关联弱实体集和标识性强实体集的联系集以**双边框菱形**表示

![alt text](figures\ch6_08.png)

### 6.6 从实体集中删除冗余属性

| 联系集名称    | 作用                                  |
| ------------- | ------------------------------------- |
| inst_dept     | 关联教师和系                          |
| stud_dept     | 关联学生和系                          |
| teaches       | 关联教师和课程段                      |
| takes         | 关联学生和课程段，具有描述性属性grade |
| course_dept   | 关联课程和系                          |
| sec_course    | 关联课程段和课程                      |
| sec_class     | 关联课程段和教室                      |
| sec_time_slot | 关联课程段和时段                      |
| advisor       | 关联学生和教师                        |
| prereq        | 关联课程和先修课程                    |
  
![alt text](figures\ch6_10.png)

### 6.7 将ER图转化为关系模式

#### 6.7.1 强实体集的表示

* 强实体集的**主码**就是所得到的模式的主码

#### 6.7.2 具有复杂属性的强实体集的表示

#### 6.7.3 弱实体集的表示

* 弱实体集的主码由**强实体集的主码**和**弱实体集的分辩符**组成

#### 6.7.4 联系集的表示

#### 6.7.5 模式的冗余

* 一般来说，连接弱实体集与其对应的强实体集的模式是冗余的。

#### 6.7.6 模式的合并

* 实体集A到实体集B的**多对一联系集**AB，可以将A和AB合并成单个模式

### 6.8 拓展的E-R特性

#### 6.8.1 特化（自顶向下）

* 在实体集内部进行分组的过程称为**特化**，用从特化实体指向另一方实体集空心箭头表示（ISA联系），表示“是一个”。
* **重叠特化**：一个实体集可以属于多个特化实体集，使用单独的箭头
* **不相交特化**：一个实体集只能属于一个特化实体集，共用单个箭头

#### 6.8.2 概化（自底向上）

* 多个实体集根据共有特征综合成一个更高层的实体集
* **概化**是在一个高层实体集（超类）与一个或多个地层实体集（子类）之间存在的包含联系，是特化的逆过程

![alt text](figures\ch6_11.png)

#### 6.8.3 属性继承

* 高层实体集的属性被低层实体集**继承**，属性继承适用于所有低层实体集
* **单继承**：一个实体集作为低层实体集只参与一个ISA联系
* **多继承**：一个实体集作为低层实体集参与多个ISA联系，产生的结构被称为格

#### 6.8.4 特化上的约束

* 完全性约束
  * **全部特化/概化**：每个高层实体集必须属于一个低层实体集，需要加入关键词```total```并画一条/一组从关键字到应用该关键字的相应空心箭头的虚线（全部特化/重叠特化）
  * **部分特化/概化**（默认）：一些高层实体集利用不属于任何低层实体集

#### 6.8.5 聚集

* 一种抽象，联系通过这种抽象被视为高层实体。

![alt text](figures\ch6_12.png)

#### 6.8.6 转换为关系模式

##### 6.8.6.1 概化的表示

1. 为高层和每个低层实体集创建一个模式，并在低层实体集上建立外码约束使其主码属性引用从高层实体集创建的关系的主码

![alt text](figures\ch6_13.png)

2. 如果概化是不相交且完全的，可以只为每个低层实体集创建模式(若用于重叠概化，则值会被不必要存储多次)

![alt text](figures\ch6_14.png)

##### 6.8.6.2 聚集的表示

* 把聚集当作其他实体集一样看待

### 6.9 实体-联系设计问题

#### 6.9.1 E-R图中的常见错误

1. 使用一个实体集主码作为另一个实体集属性，而不是使用联系
2. 将实体集的主码属性作为联系集的属性
3. 需要多值属性的情况下使用单值属性的联系

![alt text](figures\ch6_15.png)

![alt text](figures\ch6_16.png)

#### 6.9.2 使用实体集还是属性

* 依赖于具体需求，希望存储关于某属性的额外信息时用实体集更合适

#### 6.9.3 使用实体集还是联系集

* 当描述发生在实体间的行为时采用联系集

#### 6.9.4 二元还是多元联系集

* 多元联系集总可以用一组不同的二元联系集替代

### 6.10 数据建模的可选表示法

![alt text](figures\ch6_17.png)

![alt text](figures\ch6_18.png)

![alt text](figures\ch6_19.png)

## 7 关系数据库设计

### 7.1 好的关系的设计特点

#### 7.1.1 分解

* 无损分解：没有信息丢失的分解
* 有损分解：有信息丢失的分解

#### 7.1.2 无损分解

* 无损分解:$ R = R_1 $ &cup; $ R_2 $
* 关系代数表示: $ \Pi_{R_1}(r) * \Pi_{R_2}(r) = r $ 

#### 7.1.3 规范化理论

* 通过范式确定关系模式是否是“良构的”
* 如果关系模式不是“良构的”，则需要进行无损分解

### 7.2 使用函数依赖进行分解

#### 7.2.1 符号惯例

| 符号         | 含义     | 示例                  |
| ------------ | -------- | --------------------- |
| 希腊字母     | 属性集   | $\alpha$              |
| 大写罗马字母 | 关系模式 | $r(R)$                |
| $K$          | 超码     | $K$ 是 $R$ 的一个超码 |
| 小写名称     | 关系     | $instructor$          |

#### 7.2.2 码和函数依赖

* 给定$r(R)$的一个实例，对于该实例中所有元组对$t_1,t_2$,若$t_1[\alpha] = t_2[\alpha]$，则$t_1[\beta] = t_2[\beta]$，则称该实例满足**函数依赖**$\alpha → \beta$
* 如果$r(R)$的所有实例都满足函数依赖$\alpha → \beta$，则称该函数依赖在模式$r(R)$上成立

#### 7.2.3 无损分解和函数依赖

* $R_1 和 R_2$构成一个无损分解的条件：
  * $R_1 ∩ R_2 → R_1$
  * $R_1 ∩ R_2 → R_2$
* 假设将$r(R)$分解为$r_1(R_1)$和$r_2(R_2)$，其中$R_1 ∩ R_2 → R_1$，则：
  * $R_1 ∩ R_2 $是$r_1$的主码
  * $R_1 ∩ R_2 $是$r_2$的引用$r_1$的外码

### 7.3 范式

#### 7.3.1 BC范式

##### 7.3.1.1 定义

## 8 复杂数据类型

### 8.2 面向对象

#### 8.2.1 对象 - 关系数据库系统

##### 8.2.1.1 用户自定义类型

```sql 
create type Person
  (ID varchar(8) primary key,
   name varchar(50),
   address varchar(100))
   ref from(ID);
create table people of Person;

insert into people values ('12345678', 'John Smith', '123 Main St');
```

##### 8.2.1.2 类型继承

```sql
create type student under Person
  (degree varchar(50));
create type teacher under Person
  (salary decimal(10,2));
```

##### 8.2.1.3 表继承

```sql
create table students
  (degree varchar(50))
  inherits (Person);
create table teachers
  (salary integer)
  inherits (Person);

  create table people of Person;
  create table students of Student under people;
  create table teachers of Teacher under people;
```

## 14 索引

### 14.1 基本概念

* 文件索引的作用是加速查询
* 基本索引类型
  * **顺序索引**：基于值的顺序排序
  * **散列索引**：基于将值平均分布到若干桶中。一个值所属的桶是由一个函数决定的，该函数被称为*散列函数*。
* 评价指标：
  * **访问类型** (access type): 能有效支持的访问类型。访问类型可以包括找到具有特定属性值的记录，以及找到属性值落在某个特定范围内的记录。
  * **插入时间**（insertion time）：插入一个新数据项所花费的时间。该值包括找到插入这个新数据项的正确位置所花费的时间，以及更新索引结构所花费的时间。
  * **删除时间**（deletion time）：删除一个数据项所花费的时间。该值包括找到待删除项所花费的时间，以及更新索引结构所花费的时间。
  * **空间开销**（space overhead）：索引结构所占用的额外空间。倘若这种额外空间的规模适度，通常值得牺牲一定的空间来换取性能的提升。*访问时间** (access time): 在查询中使用该技术找到一个特定数据项或数据项集所花费的时间。

### 14.2 顺序索引

* 一个文件可以有多个索引，基于不同的搜索码：
  * **聚集索引/主索引**：包含记录的文件是按照某个搜索码指定的顺序排序，该搜索码对应的索引称为聚集索引/主索引，可以建立在任何搜索码上
  * **非聚集索引/辅助索引**：搜索码定义的顺序与⽂件中记录的物理顺序不同的索引，称为⾮聚集索引/辅助索引

* 不在每个属性上都建立索引的原因包括：
  * 每个索引在插入和删除期间都需要额外的 CPU 时间和磁盘 I/O 开销。非主键上的索引在更新时可能必须被修改，尽管主键上的索引可能不需要（这是因为更新通常不会修改主键属性）。
  * 非主键上的索引在更新时可能必须被修改，尽管主键上的索引可能不需要（这是因为更新通常不会修改主键属性）。
  * 每个额外的索引都需要额外的存储空间。
  * 对于涉及多个搜索键上条件的查询，即使只有部分键上建有索引，效率也可能不会太差。 因此，当已经存在许多索引时，通过添加新索引来提升数据库性能的效果会越小。
  
#### 14.2.1 稠密索引和稀疏索引

* **索引项**（index entry）或**索引记录**（index record）：由一个搜索码值 + 指向具有该搜索码值的一条或多条记录的指针构成。
* 指向记录的指针，包括：磁盘块的标识 + 表示磁盘块内记录的块内偏移量。
* 顺序索引分为两类：
  * **稠密索引**（dense index）：稠密索引中，文件中的每个搜索码值都有一个索引项。
    * **稠密聚集索引**：索引项包括搜索码值 + 指向具有该搜索码值的第一条记录的指针，具有相同搜索码值的记录顺序地存储在第一条数据记录之后。记录根据搜索码值进行排序。
    * **稠密非聚集索引**：索引项必须存储指向所有具有相同搜索码值的记录。
  * **稀疏索引**（sparse index）：稀疏索引中，只为搜索码的某些值建立索引项。只有当关系按照搜索码顺序存储时才能使用稀疏索引，换句话说，只有聚集索引才能使用稀疏索引。索引项由搜索码值 + 指向具有该搜索值的第一条记录的指针。
* 为了定位一条记录，先找到最大搜索码值小于所查找记录的搜索码值的索引指针，然后从该指针指向的记录开始顺序查找，直到找到记录为止。
* 稠密索引 VS 非稠密索引
  * 稠密索引定位记录更快，但是非稠密索引占据的空间较小，并且插入和删除时维护索引的开销也较小。
  * 具体使用时，必须在时间和空间上进行权衡。但是每个块建立稀疏索引也是一个较好的折中。这是因为：处理数据库查询的开销主要在于把块读入到主存的时间决定。一旦记录放入主存，则扫描整个块的时间可以忽略。
  * 使用这样的稀疏索引，可以定位包含索要查找记录的块，这样只要记录不在溢出块，就能使访问次数最小，同时保持索引尽可能小。

![alt text](figures\ch16_01.png)

#### 14.2.2 多级索引

#### 14.2.3 索引更新

#### 14.2.4 辅助索引

#### 14.2.5 多码索引

### 14.3 B+树

## 17.事务

### 17.1 事务概念

* **事务**是访问并能更新各种数据项的一个程序执行**单元**
* 事务的特性：
  * 原子性
  * 一致性
  * 隔离性
  * 持久性

### 17.2 一个简单的事务模型

* 操作：
  * **read(X)**：从数据库中把数据项X传送给一个也叫X的变量，X位于执行read操作事务的主存缓冲区中
  * **write(X)**：从执行write操作事务的主存缓冲区中把变量X的值传给数据库中的数据项X
* 事务定义：$T_{i}$是从账户A转账50$到账户B的事务

![alt text](figures\ch17_01.png)

* ACID特性分析
  * 一致性：事务的执行不改变A和B的总和
  * 原子性：除了事务的执行期间，不一致状态是不可见的，事务操作要么在数据库全部反映出来，要么都不反映
  * 持久性：
  * 隔离性
* 保证事务原子性的方法：数据库系统（在磁盘上）记录事务要执行写操作的任何数据项的旧值。这种信息记录在一个称为日志（log）的文件中。如果该事务没能完成它的执行，数据库系统从日志中恢复出旧值，使得看上去好像该事务从未执行过一样。保证原子性是数据库系统的责任，具体来说，这项工作由称作**恢复系统**（recovery system）的数据库组件处理。
* 保证事务持久性的方法：
  * 由事务所执行的更新在事务结束前就已经写入磁盘
  * 有关事务已执行的更新信息被写入磁盘，并且这些信息足以使数据库在故障后重新启动数据库系统时重建这些更新

### 17.3 存储器结构

* **易失性存储器**：主存，高速缓存
* **非易失性存储器**：磁盘，闪存
* **稳定存储器**：磁盘

### 17.4 事务的原子性和持久性

* 一旦事务提交就不能人为中止，撤销已提交事务造成的影响的唯一方式是编写**补偿事务**
* 事务的状态：
  * **活跃**（active）状态，为初始状态，当事务执行时就处于这种状态。
  * **部分提交**（partially committed）状态，在最后一条语句被执行之后。
  * **失效**（failed）状态，在发现正常执行不能再继续之后。
  * **中止**（aborted）状态，在事务已回滚并且数据库已被恢复到它在事务开始前的状态之后。
  * **提交**（committed）状态，在成功完成之后。
  * 已提交：事务进入提交状态
  * 中止：事务进入中止状态
  * 终止：事务进入提交或中止状态

![alt text](figures\ch17_02.png)

* 事务一开始是活跃状态，完成最后一条语句后进入**部分提交状态**
* 事务中止后，系统的选择
  * **重启**事务：引起事务中止的原因是硬件错误或不是由于事务内部逻辑产生的软件错误，重启的事务被称为新事物
  * **杀死**事务：事务内部逻辑错误，需要程序改写；或者是输入错误

### 17.5 事务的隔离性

* 并发的好处
  * 提高吞吐量和资源利用率
  * 减少等待时间
* **并发控制机制**：数据库系统控制并发事务之间的交互，防止它们破坏数据库的一致性
* **调度**：事务执行顺序

### 17.6 可串行化

* 若两道连续的执行I和J引用相同的数据项，只有在**I和J全为read**的情况下，相对顺序才无关紧要
  
![alt text](figures\ch17_03.png)

* **指令冲突**：I与J是由不同事务在相同数据项上执行的操作，且至少有一条指令是write操作
* 非冲突的指令顺序可以交换
* **冲突等价**：如果调度A可以经过一系列非冲突指令交换转换到调度B
* **冲突可串行化**：调度A和一个串行调度是冲突等价的
* 判断调度是否是冲突可串行话的方法：构建优先图
  * 图由两部分$G=(V,E)$组成，$V$为顶点集，$E$为边集，边集由满足以下三个条件之一的所有$T_i → T_j$的边组成
  * ![alt text](figures\ch17_04.png)
  * 若G无环，则G是可串行化的
  
### 17.7 事务的隔离性和原子性

#### 17.7.1 可恢复调度

* **可恢复调度**：对于每对事务$T_i$和$T_j$，如果$T_j$读取了由$T_i$之前所写过的数据项，则$T_i$的提交操作出现在$T_j$的提交操作之前。
* 为了使调度9的示例是可恢复的，$T_7$应该推迟到$T_6$提交之后再提交

![alt text](figures\ch17_05.png)

#### 17.7.2 无级联调度

* **级联回滚**：因单个事务失效而导致一系列事务回滚
* **无级联调度**：对于每对事务$T_i$和$T_j$，如果$T_j$读取了由$T_i$之前所写过的数据项，则$T_i$的提交操作必须出现在$T_j$这一读操作之前

### 17.8 事务的隔离性级别

* SQL标准规定的隔离性级别：
  * **可串行化**（serializable）：通常保证可串行化的执行。然而，正如我们将要简要解释的，一些数据库系统以在某些情况下可能允许非可串行化执行的方式来实现这种隔离性级别。
  * **可重复读**（repeatable read）：只允许读取已提交的数据，并进一步要求在一个事务两次读取一个数据项期间，其他事务不得更新该数据项。但是，该事务对于其他事务来说可能不是可串行化的。例如，当一个事务在查找满足某些条件的数据时，它可能找到一些由一个已提交事务所插入的数据，但可能找不到由同一个事务所插入的其他数据。
  * **已提交读**（read committed）：只允许读取已提交数据，但并不要求可重复读。例如，在事务两次读取一个数据项期间，另外的事务可以更新该数据项并提交。
  * **未提交读**（read uncommitted）：允许读取未提交数据。这是 SQL 允许的最低隔离性级别。
* 不允许**脏写**：如果一个数据项已经被另外一个尚未提交或中止的事务写过，则不允许对该数据再进行写操作

### 17.9 隔离性级别的实现

#### 17.9.1 锁

#### 17.9.2 时间戳

#### 17.9.3 多版本和快照隔离

### 17.10 事务的SQL语句表示