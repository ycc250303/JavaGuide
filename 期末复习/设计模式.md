## 设计模式中英文对照

### 一、创建型模式（Creational Patterns）—— 5 种

1. 单例模式（Singleton）
2. 工厂方法模式（Factory Method）
3. 抽象工厂模式（Abstract Factory）
4. 建造者模式（Builder）
5. 原型模式（Prototype）

### 二、结构型模式（Structural Patterns）—— 7 种

6. 适配器模式（Adapter）
7. 桥接模式（Bridge）
8. 组合模式（Composite）
9. 装饰器模式（Decorator）
10. 外观模式（Facade）
11. 享元模式（Flyweight）
12. 代理模式（Proxy）

### 三、行为型模式（Behavioral Patterns）—— 11 种

13. 策略模式（Strategy）
14. 模板方法模式（Template Method）
15. 观察者模式（Observer）
16. 迭代器模式（Iterator）
17. 责任链模式（Chain of Responsibility）
18. 命令模式（Command）
19. 备忘录模式（Memento）
20. 状态模式（State）
21. 访问者模式（Visitor）
22. 中介者模式（Mediator）
23. 解释器模式（Interpreter）

## 名词术语

Encapsulation / Encapsulate 封装

Inheritance 继承

Polymorphism 多态

Aggregation 聚合

cohesive 内聚

Composition 组合

Comply 遵守

violate 违反

coupling 耦合

tightly coupled 紧耦合

explicitly 明确地

compatible 兼容

lifecycle 生命周期

access 访问

wrapped object 包装的对象

snapshots 快照

## SOLID原则

* 单一职责原则：Single Responsibility Principle
  * A class should have just one reason to change
* 开闭原则：Open/Closed Principle
  * Classes should be open for extension but closed for
    modification
* 里氏替换原则：Liskov Substitution Principle
* 接⼝隔离原则 ：Interface Segregation Principle
* 依赖倒转原则：Dependency Inversion Principle

# 设计模式使用场景

## 创建型模式

| 模式名称   | 例子                                                           | 使用场景                                                                                                   | 优点                                                 | 缺点                       | Java 应用                                                                     |
| ---------- | -------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- | -------------------------- | ----------------------------------------------------------------------------- |
| 工厂方法   | 物流开发应用，需要卡车也需要轮船<br />开发跨平台UI组件         | 无法预知对象确切类别和依赖关系<br />用户能扩展软件的组件<br />复用现有对象                                 | 单一职责<br />开闭原则                               | 代码复杂                   | `Calendar#getInstance()`：根据当前时区和语言环境创建日历对象                |
| 抽象工厂   | 家具工厂，生产不同风格的家具<br />跨平台创建UI组件库           | 生产一组产品而非具体类                                                                                     | 单一职责<br />开闭原则<br />避免产品类和客户端紧耦合 | 代码复杂                   | `DocumentBuilderFactory#newInstance()`：创建能产生不同 XML 解析器的工厂实例 |
| 生成器模式 | 建造房屋<br />生产汽车<br />将多参数的构造函数变为独立的生成器 | 避免重叠构造函数（telescoping constructor）<br />用代码创建不同形式的产品 <br />构造组合数或者其他复杂对象 | 单一职责<br />复用相同代码                           | 代码复杂                   | `StringBuilder#append()`：通过连续调用方法逐步构建复杂的字符串对象          |
| 原型模式   | 复制                                                           | 复制对象<br />子类区别仅在于初始化方式，减少子类数量                                                       |                                                      | 难以克隆循环引用的复杂对象 | `Object#clone()`：允许对象通过复制现有实例（浅拷贝或深拷贝）来创建新对象    |
| 单例模式   | -                                                              | -                                                                                                          |                                                      | 违反单一职责               | `Runtime#getRuntime()`：确保整个 Java 应用运行过程中只有一个运行时环境实例  |

## 结构型模式

| 模式名称   | 例子                                                    | 使用场景                                                                                                                                 | 优点                                                         | 缺点                         | Java 应用                                                                            |
| ---------- | ------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ | ---------------------------- | ------------------------------------------------------------------------------------ |
| 适配器模式 | 将XML转化为JSON输入函数库<br />方钉圆孔<br />电源适配器 | 使用接口与其他代码不兼容的类                                                                                                             | 单一职责<br />开闭原则                                       | 代码复杂                     | `Arrays#asList()`：将原始的数组结构“适配”成 `List` 集合接口进行操作            |
| 桥接模式   | 形状与颜色的组合<br />设备与遥控器                      | 拆分或重组具有多重功能的复杂类<br />在运行时切换不同实现方法                                                                             | 单一职责<br />开闭原则<br />抽象                             | 代码复杂                     | JDBC API：通过 `DriverManager` 将抽象的数据库操作与具体的数据库驱动实现解耦        |
| 组合模式   | 盒子订单、盒子套盒子                                    | 树状对象结构<br />客户端相同方式处理不同元素                                                                                             | 开闭原则<br />利用多态和递归使用树结构                       | 难以提供公共接口             | Swing/AWT `Container`：容器可以包含多个组件（Component），形成树状的 UI 结构       |
| 装饰器模式 | 收到不同组合的社交媒体通知                              | 无需修改代码使用对象并增加额外行为<br />无法用继承扩展对象行为                                                                           | <br />单一职责<br />运行时添加或删除对象<br />多个装饰器组合 |                              | `BufferedInputStream(InputStream)`：通过包装基础流，动态地为输入流添加缓冲功能     |
| 外观模式   | 电商的复杂流程                                          | 指向复杂子系统的直接接口<br />将子系统分为多层                                                                                           | 从复杂子系统中隔离代码                                       | 外观上帝类                   | `FacesContext`：为 JavaServer Faces 内部复杂的请求处理过程提供了一个简化的访问入口 |
| 享元模式   | 游戏资源共享                                            | 程序存在大量重复且可共享状态的对象<br />（时间换空间）                                                                                   | 节省内存                                                     | 牺牲速度换内存<br />代码复杂 | `Integer#valueOf(int)`：缓存并复用 -128 到 127 之间的整数对象以减少内存消耗        |
| 代理模式   | 客户端直接访问数据库                                    | 延迟初始化：虚拟代理<br />访问控制：保护代理<br />本地执行远程服务：远程代理<br />记录日志请求：日志记录代理<br />缓存请求结果：缓存代理 | 开闭原则                                                     | 代码复杂<br />服务器返回延迟 | `java.lang.reflect.Proxy`：在运行时为目标对象创建代理，常用于 AOP、权限控制等      |

## 行为型模式

| 模式名称     | 例子                                    | 使用场景                                                                 | 优点                                                                      | 缺点                                    | Java 应用                                                                         |
| ------------ | --------------------------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------------- | --------------------------------------- | --------------------------------------------------------------------------------- |
| 策略模式     | 地图的不同导航方式                      | 程序运行时切换算法<br />隔离算法实现和业务逻辑                           | 组合代替继承<br />开闭原则                                                | 过度设计                                | `Comparator#compare()`：通过传入不同的比较器，在运行时改变集合的排序算法        |
| 模板方法模式 | 提取不同后缀文件的内容                  | 多个类的算法只有细微不同                                                 | 提取重复代码                                                              | 维护困难<br />违反里氏替换原则          | `AbstractList#indexOf()`：在基类定义算法骨架，由子类实现具体的元素定位逻辑      |
| 观察者模式   | 订阅杂志<br />关注微信公众号            | 一个状态对象的改变需要改变其他对象<br />应用中的对象需要观察其他对象     | 开闭原则<br />运行时建立对象的连携                                        | 订阅者（Subscribers）的通知顺序是随机的 | 事件监听机制：如 AWT/Swing 中的 `ActionListener` 监听按钮点击等状态变化         |
| 迭代器模式   | 遍历元素                                | 集合有一个复杂的数据结构<br />减少重复的遍历代码<br />遍历不同的数据结构 | 单一职责<br />开闭原则<br />并行遍历                                      | 过度设计                                | `Iterator`：为各种集合（List, Set 等）提供统一的遍历方式，而无需暴露底层结构    |
| 责任链模式   | 电商系统繁杂的认证授权<br />电脑GUI操作 | 按顺序执行多个处理者<br />处理者和顺序需要在运行时改变                   | 单一职责<br />开闭原则<br />控制处理顺序                                  | 请求可能不会被处理                      | Servlet `Filter#doFilter()`：多个过滤器形成链条，按顺序对 HTTP 请求进行预处理   |
| 命令模式     | -                                       | 通过操作参数化对象<br />将操作放入队列<br />操作回滚                     | 单一职责<br />开闭原则<br />操作撤销/恢复<br />操作延迟执行<br />组合命令 | 代码复杂                                | `Runnable`：将任务封装成对象，以便在不同时间、线程中执行或放入队列管理          |
| 备忘录模式   | 开发拥有撤回功能的文字编辑器            | 创建对象恢复之前的状态<br />直接访问变量会违反封装                       |                                                                           |                                         | 对象序列化：通过将对象状态存入字节流，实现对象在内存或磁盘上的状态保存与恢复      |
| 状态模式     | 电梯状态                                | 对象有很多状态，且状态相关代码会频繁变更                                 | 单一职责<br />开闭原则<br />简化上下文代码                                | 状态很少可能过度设计                    | JSF `Lifecycle`：根据当前请求所处的阶段（如恢复视图、应用请求值等）执行不同逻辑 |
| 访问者模式   | -                                       | -                                                                        | 单一职责<br />开闭原则                                                    |                                         | `FileVisitor`：在遍历文件树时，对不同类型的文件（目录、文件等）执行特定的操作   |
| 中介者模式   | 对话框程序的各种组件<br />飞机和灯塔    | 对象存在紧耦合且难以修改                                                 | 单一职责<br />开闭原则<br />减轻耦合<br />复用组件                        | 上帝对象                                | `Timer#schedule()`：协调任务调度器与具体任务之间的关系，避免它们直接耦合        |
